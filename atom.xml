<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Translate somethings]]></title>
  <link href="http://tairan.github.com/translator/atom.xml" rel="self"/>
  <link href="http://tairan.github.com/translator/"/>
  <updated>2013-01-27T22:13:30+08:00</updated>
  <id>http://tairan.github.com/translator/</id>
  <author>
    <name><![CDATA[Tairan Wang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to use git over an HTTP proxy, with socat]]></title>
    <link href="http://tairan.github.com/translator/blog/2013/01/27/how-to-use-git-over-an-http-proxy/"/>
    <updated>2013-01-27T18:22:00+08:00</updated>
    <id>http://tairan.github.com/translator/blog/2013/01/27/how-to-use-git-over-an-http-proxy</id>
    <content type="html"><![CDATA[<p><a href="http://sitaramc.github.com/tips/git-over-proxy.html">原文链接</a></p>

<p>如何使用<code>socat</code>让<code>git</code>通过HTTP代理</p>

<p>Corporate firewalls and proxy typically block both of these (and often a lot more); here&#8217;s how to get around them.</p>

<p>企业防火墙和代理通常会阻止它们(通常还有很多)，这里则是教你如何绕过它们。</p>

<p>If you&#8217;re tracking a public repo, you will need to use the &#8220;git&#8221; protocol, because the &#8220;http&#8221; protocol is not very efficient, and/or requires some special handling on the server side. If you&#8217;re pushing code to a public repo, you definitely need to use the &#8220;ssh&#8221; protocol.</p>

<p>如果你在跟踪一个公共的仓库，你需要使用git协议，因为http协议不是很有效，在服务器端一些特殊的处理。如果你推送代码到公共的仓库，你一定要使用ssh协议。</p>

<h2>a word about socat</h2>

<p>I will be using &#8220;socat&#8221;, an absolute corker of a program that does so many things it&#8217;s incredible! Other people use corkscrew, ssh-https-tunnel, etc., which are all specialised for just one purpose. I prefer socat, and once you spend the 2-3 years :-) needed to read the man page, you will see why!</p>

<p>我会使用&#8221;socat&#8221;， 一个绝对的程序corker能做这么多事情，是多么难以置信的！ 其他人使用 <code>corkscrew</code>, <code>ssh-https-tunnel</code>等。这些工具都只有一个目的。我喜欢socat，一旦你花上个2-3年去读它的手册，你就会明白的。</p>

<p>The basic idea is that you will somehow invoke socat, which will negotiate with the HTTP(S) proxy server using the CONNECT method to get you a clean pipe to the server on the far side.</p>

<p>一个基本的思想是你会如何调用socat，它会和https代理服务进行交涉，使用一个连接方法给你一个干净的管道在远端服务器。</p>

<p>However, do note that socat does have one disadvantage: the passwords to your proxy server are visible in to local users running <code>ps -ef</code> or something. I don&#8217;t care since I don&#8217;t have anyone else logging into my desktop, and the ability to use a program I already have anyway (socat) is more important.</p>

<p>然而，注意socat确实有个缺点: 在本地用户运行<code>ps -ef</code> or 其他的什么的时候，你代理服务器的密码是可见的。我不在乎，我知道没其他人登录到我的桌面电脑，并且我已经在任何地方都有一个程序（socat）是如此的重要。</p>

<h2>proxying the git protocol</h2>

<p>When I want to download a public repo, I just type</p>

<p>当我想要下载一个公共仓库的时候，我只要输入</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>proxied_git clone ...repo...
</span><span class='line'>proxied_git pull
</span></code></pre></td></tr></table></div></figure>


<p>and so on, instead of</p>

<p>替代下面的</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git clone ...repo...
</span><span class='line'>git pull
</span></code></pre></td></tr></table></div></figure>


<p>Here&#8217;s the how and why of it.</p>

<p>这里你会知道为什么这样做</p>

<p>To proxy the git protocol, you need to export an environment variable called <code>GIT_PROXY_COMMAND</code>, which contains the command that is to be invoked. I have a shell function in my <code>.bashrc</code> that looks like this:</p>

<p>要代理<code>git</code>协议，你需要一个环境变量<code>GIT_PROXY_COMMAND</code>, 它包含了需要被调用的命令。我把它写在了 <code>.bashrc</code> 中，如下</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>proxied_git <span class="o">()</span>
</span><span class='line'><span class="o">(</span>
</span><span class='line'>    <span class="nb">export </span><span class="nv">GIT_PROXY_COMMAND</span><span class="o">=</span>/tmp/gitproxy;
</span><span class='line'>
</span><span class='line'>    cat  &gt; <span class="nv">$GIT_PROXY_COMMAND</span> <span class="s">&lt;&lt;EOF</span>
</span><span class='line'><span class="s">#!/bin/bash</span>
</span><span class='line'><span class="s">/usr/bin/socat - PROXY:172.25.149.2:\$1:\$2,proxyport=3128</span>
</span><span class='line'><span class="s">EOF</span>
</span><span class='line'>    chmod +x <span class="nv">$GIT_PROXY_COMMAND</span>;
</span><span class='line'>
</span><span class='line'>    git <span class="s2">&quot;$@&quot;</span>
</span><span class='line'><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Possible variations are:</p>

<p>可能的变化</p>

<ul>
<li>you could give <code>/tmp/gitproxy</code> a more permanent name and remove the middle pararaph completely. I don&#8217;t do this because that&#8217;s too small a file to bother with; it just seems cleaner this way)</li>
<li>你可以给 <code>/tmp/gitproxy</code> 一个永久的名称并移除中间部分。我没有做这个因为这只是一个很小的文件，这个方法似乎也很清洁。</li>
<li>you could permanently set the environment variable if all your git repos are remote (very unlikely)</li>
<li>如果你的git仓库都在远端，你可以永久的设置一个环境变量(不太可能)</li>
</ul>


<p>One thing you cannot do is to roll the entire socat command into the environment variable. Git passes the host and port as two arguments to the proxy command, but socat expects them in the syntax you see above, so you will need to wrap it in a script as I have done. I guess you could argue that this is a point in favour of corkscrew etc. ;-)</p>

<p>一个事情是你不能做的就是roll整个socat命令到环境变量里。git通过host和port作为代理命令的两个参数，但是socat期望它们在你在上面看到的语法，所以你会需要使用一个脚本去包装它。我想你可能会说这点是corkscrew常用的等。</p>

<h2>proxying the ssh protocol</h2>

<p>The git protocol is handled directly by git (duh!), but if you use the ssh protocol, it invokes ssh explicitly (again, duh!).</p>

<p>git协议是由git直接处理的，但是如果你使用ssh协议，它会调用ssh。</p>

<p>Ssh already has this sort of stuff built-in, so you simply add a few lines to your <code>~/.ssh/config</code></p>

<p>ssh 通常都会内置，所以你仅需要在你的 <code>~/.ssh/config</code> 中加入几行</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='apache'><span class='line'><span class="nb">host</span> gh
</span><span class='line'>    <span class="nb">user</span> git
</span><span class='line'>    <span class="nb">hostname</span> github.com
</span><span class='line'>    <span class="nb">port</span> <span class="m">22</span>
</span><span class='line'>    <span class="nb">proxycommand</span> socat - PROXY:your.proxy.ip:%h:%p,proxyport=3128,proxyauth=user:pwd
</span></code></pre></td></tr></table></div></figure>


<p>Now you can just say (for example):</p>

<p>现在你可以这样使用</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>git clone gh:sitaramc/git-notes.git
</span></code></pre></td></tr></table></div></figure>


<h3>ssh proxy using corkscrew instead of socat</h3>

<p>ssh代理使用corkscrew替代socat</p>

<p>download and install <a href="http://www.agroman.net/corkscrew/">corkscrew</a></p>

<p>下载并安装<a href="http://www.agroman.net/corkscrew/">corkscrew</a></p>

<p>create a file (eg., <code>~/.ssh/myauth</code>) and put your http proxy username and password as <code>"username:password"</code> in it and save it.
safeguard the file</p>

<p>创建一个文件(比如<code>~/.ssh/myauth</code>)并输入你的http代理的用户名和密码，格式为<code>"username:password"</code>，然后保存。修改它的权限</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>chmod 600 ~/.ssh/myauth
</span></code></pre></td></tr></table></div></figure>


<p>open <code>~/.ssh/config</code> and add the following entry, adding an explicit path to corkscrew if needed.</p>

<p>打开 <code>~/.ssh/config</code> 并且增加下面的一些代码，如果需要的话，给scorkscrew一个完整的路径。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='apache'><span class='line'><span class="nb">host</span> gh
</span><span class='line'>    <span class="nb">user</span> git
</span><span class='line'>    <span class="nb">hostname</span> github.com
</span><span class='line'>    <span class="nb">port</span> <span class="m">22</span>
</span><span class='line'>    <span class="nb">proxycommand</span> corkscrew your.proxy.ip <span class="m">3128</span> %h %p ~/.ssh/myauth
</span></code></pre></td></tr></table></div></figure>


<h3>extra coolness for github</h3>

<p>Noting that many corporate firewalls block access to the CONNECT method on ports other than 443, the good folks at github have an ssh server listening on 443 if you use the host <code>"ssh.github.com"</code>, so you can replace the hostname and the port in the above ssh config stanza as appropriate, and you&#8217;re all set</p>

<p>很多防火墙会阻挡443端口的连接，作为一个github的好公民，如果你使用<code>"ssh.github.com"</code>，需要又一个ssh服务器去监听443端口， 那么你可以替换这个主机名和端口号在ssh config中，好了，搞定。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing DNSCrypt]]></title>
    <link href="http://tairan.github.com/translator/blog/2013/01/13/introducing-dnscrypt/"/>
    <updated>2013-01-13T18:24:00+08:00</updated>
    <id>http://tairan.github.com/translator/blog/2013/01/13/introducing-dnscrypt</id>
    <content type="html"><![CDATA[<p>国内的网络通畅形势越来越严峻，网络被重置、无法访问的情况时有发生。而网络基础协议之一的DNS使用加密连接也成为必须的选择。OpenDNS就提供了一种对DNS进行加密的解决方案:DNSCrypt。这篇文章就是翻译其对DNSCrypt的介绍。</p>

<p><a href="http://www.opendns.com/technology/dnscrypt/">原文链接</a></p>

<h2>Introducing DNSCrypt (Preview Release)</h2>

<p>介绍DNSCrypt (发布预览)</p>

<h3>Background: The need for a better DNS security</h3>

<p>背景: 需要更好的DNS加密</p>

<p>DNS is one of the fundamental building blocks of the Internet.  It&#8217;s used any time you visit a website, send an email, have an IM conversation or do anything else online.  While OpenDNS has provided world-class security using DNS for years, and OpenDNS is the most secure DNS service available, the underlying DNS protocol has not been secure enough for our comfort.  Many will remember the <a href="http://www.unixwiz.net/techtips/iguide-kaminsky-dns-vuln.html">Kaminsky Vulnerability</a>, which impacted nearly every DNS implementation in the world (though not OpenDNS).</p>

<p>DNS 是无联网的一个基础的组成部分。它应用在你访问网站，发送Email，实时聊天等任何的在线活动。多年来，OpenDNS一直提供世界级安全的DNS，并且OpenDNS提供的安全DNS服务是有效的，DNS协议并不是足够安全。很多人还会记得Kamisky Vulnerability，它影响了这个世界上的每一个DNS实现(不是通过OpenDNS)。</p>

<p>That said, the class of problems that the Kaminsky Vulnerability related to were a result of some of the underlying foundations of the DNS protocol that are inherently weak  &#8211; particularly in the &#8220;last mile.&#8221;  The &#8220;last mile&#8221; is the portion of your Internet connection between your computer and your ISP.  DNSCrypt is our way of securing the &#8220;last mile&#8221; of DNS traffic and resolving (no pun intended) an entire class of serious security concerns with the DNS protocol. As the world’s Internet connectivity becomes increasingly mobile and more and more people are connecting to several different WiFi networks in a single day, the need for a solution is mounting.</p>

<p>表明，和Kamisky Vulnerability相关的一类问题是由于DNS协议自身问题的结果。&#8211; particularly in the &#8220;last mile.&#8221; &#8220;最后一公里&#8221;是指你的电脑和ISP之间的互联网连接。DNSCrypt是我们的安全解决方案，保证DNS传输的“一公里”的安全和解析每一类DNS协议安全连接场景。当今世界已经成为移动互联网，很多人在一天中使用多种不同的WiFi接入到网络，我们需要一揽子的解决方案。</p>

<p>There have been numerous examples of tampering, or man-in-the-middle attacks, and snooping of DNS traffic at the last mile and it represents a serious security risk that we&#8217;ve always wanted to fix. Today we can.</p>

<p>这里有 numberous examples of tampering, 或者中间人攻击，以及在一公里进行DNS流量监控，它代表我们一直想去解决的安全风险场景。今天我们可以做到。</p>

<h3>Why DNSCrypt is so significant</h3>

<p>Why DNSCrypt is so significant</p>

<p>In the same way the SSL turns HTTP web traffic into HTTPS encrypted Web traffic, DNSCrypt turns regular DNS traffic into encrypted DNS traffic that is secure from eavesdropping and man-in-the-middle attacks.  It doesn&#8217;t require any changes to domain names or how they work, it simply provides a method for securely encrypting communication between our customers and our DNS servers in our data centers.  We know that claims alone don&#8217;t work in the security world, however, so we&#8217;ve opened up the source to our DNSCrypt code base and it&#8217;s available on <a href="http://www.github.com/opendns">GitHub</a>.</p>

<p>和使用SSL对HTTP加密网络传输方式一样，DNSCrypt在正常的DNS传输上加密，that is secure from eavesdropping and 中间人攻击。它不需要改变域名系统的工作，它在我们的客户和我们的DNS服务器之间提供一种简单的安全加密的通讯方法。我们知道我们不能在这个安全的世界内闭门造车，所以我们开放了DNSCrypt的源代码，它托管在Github中。</p>

<p>DNSCrypt has the potential to be the most impactful advancement in Internet security since SSL, significantly improving every single Internet user&#8217;s online security and privacy.</p>

<p>TODO:</p>

<p>Download Now:</p>

<ul>
<li><a href="http://opendns.github.com/dnscrypt-osx-client/">Download DNSCrypt for Mac</a></li>
<li><a href="http://shared.opendns.com/dnscrypt/packages/windows-client/DNSCryptWin-v0.0.6.exe">Download DNSCrypt for Windows</a></li>
</ul>


<h3>Frequently Asked Questions (FAQ):</h3>

<ol>
<li>In plain English, what is DNSCrypt?</li>
</ol>


<p>DNSCrypt是什么？</p>

<p>DNSCrypt is a piece of lightweight software that everyone should use to boost online privacy and security.  It works by encrypting all DNS traffic between the user and OpenDNS, preventing any spying, spoofing or man-in-the-middle attacks.</p>

<p>DNSCrypt是一个轻量级软件，它为任何一个使用在线隐私和安全的人。它可以加密所有用户和OpenDNS之间的DNS传输，preventing any spying, spoofing or man-in-the-middle attacks.</p>

<ol>
<li>How can I use DNSCrypt today?</li>
</ol>


<p>我先在可以使用DNSCrypt吗？</p>

<p>DNSCrypt is immediately available as a technology preview.  It should work, shouldn&#8217;t cause problems, but we&#8217;re still making iterative changes regularly.  You can download a version for Mac or Windows from the links above.</p>

<p>DNSCrypt作为一个技术预览版本已经可以使用。它工作起来没有什么问题，但是我们仍在改进它使它更易用。你可以从上面的链接去下载Mac或者Windows版本。</p>

<p>Tips:</p>

<p>提示:</p>

<p>If you have a firewall or other middleware mangling your packets, you should try enabling DNSCrypt with TCP over port 443.  This will make most firewalls think it&#8217;s HTTPS traffic and leave it alone.</p>

<p>如果你使用防火墙或者其它的中间件管理你的数据包，你应该尝试使用443端口。这会保证你的防火墙把它作为https传输处理。</p>

<p>If you prefer reliability over security, enable fallback to insecure DNS.  If you can&#8217;t reach us, we&#8217;ll try using your DHCP-assigned or previously configured DNS servers.  This is a security risk though.</p>

<p>TODO</p>

<ol>
<li>What about DNSSEC? Does this eliminate the need for DNSSEC?</li>
</ol>


<p>No. DNSCrypt and DNSSEC are complementary.  DNSSEC does a number of things.  First, it provides authentication. (Is the DNS record I&#8217;m getting a response for coming from the owner of the domain name I&#8217;m asking about or has it been tampered with?)  Second, DNSSEC provides a chain of trust to help establish confidence that the answers you&#8217;re getting are verifiable.  But unfortunately, DNSSEC doesn&#8217;t actually provide encryption for DNS records, even those signed by DNSSEC.  Even if everyone in the world used DNSSEC, the need to encrypt all DNS traffic would not go away. Moreover, DNSSEC today represents a near-zero percentage of overall domain names and an increasingly smaller percentage of DNS records each day as the Internet grows.</p>

<p>That said, DNSSEC and DNSCrypt can work perfectly together.  They aren&#8217;t conflicting in any way.  Think of DNSCrypt as a wrapper around all DNS traffic and DNSSEC as a way of signing and providing validation for a subset of those records.  There are benefits to DNSSEC that DNSCrypt isn&#8217;t trying to address. In fact, we hope DNSSEC adoption grows so that people can have more confidence in the entire DNS infrastructure, not just the link between our customers and OpenDNS.</p>

<ol>
<li>Is this using SSL? What&#8217;s the crypto and what&#8217;s the design?</li>
</ol>


<p>它使用SSL？用什么加密，是怎么设计的？</p>

<p>We are not using SSL.  While we make the analogy that DNSCrypt is like SSL in that it wraps all DNS traffic with encryption the same way SSL wraps all HTTP traffic, it&#8217;s not the crypto library being used.  We&#8217;re using elliptical-curve cryptography, in particular the <a href="http://dnscurve.org/crypto.html">Curve25519</a> eliptical curve.  The design goals are similar to those described in the <a href="http://dnscurve.org/out-implement.html">DNSCurve forwarder</a> design.</p>

<p>我们没有使用SSL。 一直以来我们说DSNCrypt类似SSL，它是对DNS传输的包装，是和SSL对HTTP传输的包装的路子一样， 它没有使用任何的加密库。 我们使用elliptical-curve加密算法。设计目标和DNSCurve formarder设计的类似。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rake Tutorial 2]]></title>
    <link href="http://tairan.github.com/translator/blog/2013/01/04/rake-tutorial-2/"/>
    <updated>2013-01-04T14:38:00+08:00</updated>
    <id>http://tairan.github.com/translator/blog/2013/01/04/rake-tutorial-2</id>
    <content type="html"><![CDATA[<p><a href="http://docs.rubyrake.org/tutorial/chapter02.html">Rake Tutorial</a></p>

<h2>Chapter 2—Managing Files with FileLists</h2>

<p>Handling Common Actions</p>

<p>处理通用动作</p>

<blockquote><p>Rake is a tool for controlling builds. In this part of the Rake tutorial, we see how to organize the Rake actions to apply to many similar tasks.</p>

<p>Rake 是一个用来控制build的工具。在此指南的这部分，我们去看如何组织Rake动作并应用到相似的任务中去。</p>

<p>In the previous chapter, we talked about the basics of specifying dependencies and associating actions to build the files. We ended up with a nice Rakefile that built our simple C program, but with some duplication in the build rules.</p>

<p>在前一个章节中，我们谈论了关于去构建Rakefile用到特定依赖和关联行为的基本知识。最后我们有了一个不错的用来build我们简单的C程序的Rakefile，但是在build规则中有一些重复。</p></blockquote>

<p>But First, Some Extra Rake Targets</p>

<p>首先，一些额外的Rake目标</p>

<p>But before we get into all that, lets add some convience targets to our Rakefile. First of all, it would be nice to have a default target that is invoked when we don’t give any explicit task names to rake. The default target looks like this:</p>

<p>在我们深入开始之前，让我们为Rakefile添加一些切实可行的目标。首先，当我们没有为rake明确声明任务名称时，它会被作为默认的目标被调用。这个默认的目标如下</p>

<p>Rakefile Fragment</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">task</span> <span class="ss">:default</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;hello&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Until now, the only kind of task we have seen in Rake are file tasks. File tasks are knowledgable about time stamps on files. A file task will not execute its action unless the file it represents doesn’t exist, or is older than any of its prerequisites.</p>

<p>直到现在，在Rake中我们看到的唯一的任务类型是file tasks。File tasks很擅长于文件上的时间戳处理。 除非file task代表它不存在，或者比它要求的时间更旧，否则file task不会执行这个动作。</p>

<p>A non-file task (or just plain “task”) does not represent the creation of a file. Since there is no timestamp for comparison, non-file tasks always execute their actions (if they have any). Since the default task does not represent a file named “default”, we use a regular non-file task for this purpose. Non-file tasks just use the task keyword (instead of the file keyword).</p>

<p>一个非文件任务(或只是简单的“task”) 并不代表创建一个文件。因为这里没有时间戳用来比对，所以非文件任务总是执行这些动作(如果它有的话)。默认的任务不代表一个叫“default”的文件，为了这个目的，我们使用一个非文件任务。非文件任务只是用任务关键字。（替代file关键字）</p>

<p>Here are a couple of other really useful tasks that I almost always include in a Rakefile.</p>

<p>这里有一组真实有用的任务，我通常总会将他们包含在Rakefile中。</p>

<p>clean:</p>

<pre><code>Remove temporary files created during the build process.
</code></pre>

<p>清理:</p>

<pre><code>移除在build过程期间创建的临时文件。
</code></pre>

<p>clobber:</p>

<pre><code>Remove **all** files generated during the build process.
</code></pre>

<p>clobber:</p>

<pre><code>移除所有在build过程期间生成的文件。
</code></pre>

<p>clean tidies up the directories and removes any files that generated as part of the build process, but are not the final goal of the build process. For example, the .o files used to link up the final executable hello program would fall in this category. After the executable program is built, the .o files are no longer needed and will be removed by saying “rake clean”.</p>

<p>整理目录，并且清理在build处理期间生成的文件，但不是build流程最终的目标结果。例如： 用来link最终可执行程序的.o 文件都归为这类。 在可执行程序build完成之后，.o 文件就不再需要了，把它们移除掉可以称为&#8221;rake clean&#8221;。</p>

<p>clobber is like clean, but even more aggressive. “rake clobber” will remove all files that are not part of the original package. It should return a project to the “just checked out of CVS” state. So it removes the final executable program as well as the files removed by clean.</p>

<p>colbber类似clean，但是更具有侵略性. &#8220;rake colbber&#8221;会移除所有不是原包中的所有文件。它会回到“刚刚从cvs中checkout”的状态。因此它会做clean相关的移除外还会删除最终的可执行程序。</p>

<p>In fact, these tasks are so common, Rake comes with a predefined library that implements clean and clobber.</p>

<p>实际上，这些任务是如此的通用，Rake有预定义的库来实现清理和clobber.</p>

<p>But every project is different, how do we specify which files are to be cleaned and clobbered on a per project basis?</p>

<p>但是每个项目的都不尽相同，我们怎么为每个项目指定哪些文件需要被清理和clobbered呢？</p>

<p>The answer is File lists.</p>

<p>答案是，文件列表。</p>

<p>File Lists to the Rescue</p>

<p>文件列表去拯救</p>

<p>A file list is simply a list of file names. Since a lot of what Rake does involves files and lists of those files, a file list has some special features to make manipulating file names rather easy.</p>

<p>文件列表是一个简单的文件名字的列表。因为Rake做的很多事情是调用文件和那些文件的列表，所以这个文件列表具有一些特征使处理文件名更容易。</p>

<p>Suppose you want a list of all the C files in your project. You could add this to your rake file:</p>

<p>假如你想要一个在你项目中所有C文件的列表。你可以增加下面的代码在你的Rakefile中。</p>

<p>Rakefile Fragment</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SRC</span> <span class="o">=</span> <span class="no">FileList</span><span class="o">[</span><span class="s1">&#39;*.c&#39;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>This will collect all the files ending in ”.c” in the top level directory of your project. File lists understand glob patterns (i.e. things like &#8220;.c&#8221;) and will find all the matching files.</p>

<p>这会手机你项目中顶级目录中文件名以&#8221;.c&#8221;结尾的文件。文件列表支持glob模式。(i.e. 比如 &#8220;.c&#8221;)并且会找到所有符合的文件。</p>

<p>By the way, no matter where you invoke it, rake always executes in the directory where the Rakefile is found. This keeps your path names consistent without depending on the current directory the user interactive shell.</p>

<p>顺便提一下, 无论你在什么地方调用它, rake总是在Rakefile所在的目录中执行。这能保证你在shell中不会依赖当前目录。</p>

<p>The clean and clobber tasks use file lists to manage the files to remove. So if we want to clean up all the .o files in a project we could try …</p>

<p>清理和clobber任务使用文件列表来管理哪些文件被移除。因此如果我们需要清理项目中的所有.o文件，可以试一下..</p>

<p>Rakefile Fragment*</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">CLEAN</span> <span class="o">=</span> <span class="no">FileList</span><span class="o">[</span><span class="s1">&#39;*.o&#39;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>(CLEAN is the file list associated with the clean task. I’ll let you guess the name of the file list associated with clobber).</p>

<p>(CLEAN 是关联到清理任务的文件列表。 我会让你猜一下关联到clobber任务的文件列表名字)</p>

<h2>Chapter 3—Reducing Duplication with Rules</h2>

<p>Dynamically Building Tasks</p>

<p>动态的Building任务</p>

<p>The command to compile the main.c and greet.c files is identical, except for the name of the files involved. The simpliest and most direct way to address the problem is to define the compile task in a loop. Perhaps something like this …</p>

<p>编译 main.c 和 greet.c 文件的命令是完全一致的，除了被调用的文件名。最简单直接的方式去处理这个问题是在一个循环中定义编译任务。示例</p>

<p>Rakefile Fragment</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SRC</span> <span class="o">=</span> <span class="no">FileList</span><span class="o">[</span><span class="s1">&#39;*.c&#39;</span><span class="o">]</span>
</span><span class='line'><span class="no">SRC</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">fn</span><span class="o">|</span>
</span><span class='line'>  <span class="n">obj</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sr">/\.[^.]*$/</span><span class="p">,</span> <span class="s1">&#39;.o&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">file</span> <span class="n">obj</span>  <span class="k">do</span>
</span><span class='line'>    <span class="n">sh</span> <span class="s2">&quot;cc -c -o </span><span class="si">#{</span><span class="n">obj</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">fn</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Just a couple things to note about the above code.</p>

<p>关于上面的代码仅有两个需要注意的地方。</p>

<ul>
<li><p>The dependencies are not specified. This is a common where we specify the dependents at one place and the actions in another. Rake is smart enough to combine the dependencies with the actions.</p></li>
<li><p>依赖没有指定。这种在一个地方定义指定依赖另一个地方执行是一种普遍现象，Rake具有足够的智能去绑定这些依赖关系和行为。</p></li>
<li><p>Although the task was named after the .o (which is, after all, what we want to generate), the file list is defined in terms of the .c files. Why?</p></li>
<li><p>尽管任务使用 .o 来命名 (毕竟这些是我们想去生成的东西), 但是文件列表依照 .c 去定义，为什么呢？</p></li>
</ul>


<p>The simple reason is that file lists search for file names that exist in the file system. We have no guarantee that the .o files even exist at this point (indeed, the will not after invoking the clean task). The .c are source and will always be there.</p>

<p>一个简单的理由是文件列表在文件系统中搜索已经存在的文件的文件名。我们不能保证.o文件是一直存在的.(确实，在调用clean任务后就会没有了). .c作为源代码总是存在。</p>

<p>Rake Can Automatically Generate Tasks</p>

<p>Rake 能自动生成任务</p>

<p>Defining tasks in a loop is pretty cool, but is really not needed in a number of simple cases. Rake can automatically generate file based tasks according to some simple pattern matching rules.</p>

<p>在一个循环中定义任务很酷，但是在一些简单的任务中并不需要。Rake能基于基本的任务规则去生成相应匹配的任务。</p>

<p>For example, we can capture the above logic in a single rule … no need to find all the source files and iterate through them.</p>

<p>示例，我们可以按照一个单个的规则来捕获上面的逻辑。 不需要查找所有的源代码并迭代处理。</p>

<p>Rakefile Fragment</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rule</span> <span class="s1">&#39;.o&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;.c&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
</span><span class='line'>  <span class="n">sh</span> <span class="s2">&quot;cc -c -o </span><span class="si">#{</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">t</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The above rule says that if you want to generate a file ending in .o, then you if you have a file with the same base name, but ending in .c, then you can generate the .o from the .c.</p>

<p>上面的规则说如果你要生成一个以 .o 结尾的文件，然后如果你有一个文件和基础文件有相同的名称，但是你可以从 .c 文件生成 .o</p>

<p>t.name is the name of the task, and in file based tasks will be the name of the file we are trying to generate. t.source is the name of the source file, i.e. the one that matches the second have of the rule pattern. t.source is only valid in the body of a rule.</p>

<p>t.name 是任务的名称，在文件任务中，我们会尝试以文件的名称来命名生成的文件。 t.source 是其源文件的名字，i.e. the one that matches the second have of the rule pattern. t.source 在规则中唯一有效的。</p>

<p>Rules are actually much more flexible than you are led to believe here. But that’s an advanced topic that we will save for another day.</p>

<p>规则实际上可以做的比你想象中的更加灵活。但是那是高级话题，我们会在以后再说。</p>

<p>Final Rakefile</p>

<p>Here is our final resule. Notice how we use the SRC and OBJ file lists to manage our lists of scource files and object files.</p>

<p>这是我们最终的结果。提示我们是怎么使用SRC和OBJ文件列表去管理我们的源文件和目标文件的。</p>

<p>Rakefile</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;rake/clean&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="no">CLEAN</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="s1">&#39;*.o&#39;</span><span class="p">)</span>
</span><span class='line'><span class="no">CLOBBER</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">task</span> <span class="ss">:default</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;hello&quot;</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="no">SRC</span> <span class="o">=</span> <span class="no">FileList</span><span class="o">[</span><span class="s1">&#39;*.c&#39;</span><span class="o">]</span>
</span><span class='line'><span class="no">OBJ</span> <span class="o">=</span> <span class="no">SRC</span><span class="o">.</span><span class="n">ext</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">rule</span> <span class="s1">&#39;.o&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;.c&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
</span><span class='line'>  <span class="n">sh</span> <span class="s2">&quot;cc -c -o </span><span class="si">#{</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">t</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">file</span> <span class="s2">&quot;hello&quot;</span> <span class="o">=&gt;</span> <span class="no">OBJ</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">sh</span> <span class="s2">&quot;cc -o hello </span><span class="si">#{</span><span class="no">OBJ</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># File dependencies go here ...</span>
</span><span class='line'><span class="n">file</span> <span class="s1">&#39;main.o&#39;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s1">&#39;main.c&#39;</span><span class="p">,</span> <span class="s1">&#39;greet.h&#39;</span><span class="o">]</span>
</span><span class='line'><span class="n">file</span> <span class="s1">&#39;greet.o&#39;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s1">&#39;greet.c&#39;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rake Tutorial]]></title>
    <link href="http://tairan.github.com/translator/blog/2012/12/21/rake-tutorial/"/>
    <updated>2012-12-21T20:54:00+08:00</updated>
    <id>http://tairan.github.com/translator/blog/2012/12/21/rake-tutorial</id>
    <content type="html"><![CDATA[<p><a href="http://docs.rubyrake.org/tutorial/index.html">Rake Tutorial</a></p>

<h2>Rake 指南</h2>

<p>Rake is a build tool, written in Ruby, using Ruby as a build language. Rake is similar to make in scope and purpose. Rake a simple ruby build program with capabilities similar to make.</p>

<p>Rake 是用Ruby写的Build工具，使用Ruby作为Build语言。Rake的目标和适用范围和make类似。Rake是一个简单的Ruby程序和make具有相似的功能。</p>

<p>Rake has the following features:</p>

<p>Rake 具有以下特征</p>

<ul>
<li><p>Rakefiles (rake’s version of Makefiles) are completely defined in standard Ruby syntax. No XML files to edit. No quirky Makefile syntax to worry about (is that a tab or a space?)</p>

<p>  Rakefiles (Rake版本的Makefiles) 完全使用的标准的Ruby语法定义。不用编辑xml文件。没有Makefile的诡异语法问题比如(Tab和空格)</p></li>
<li><p>Users can specify tasks with prerequisites.</p>

<p>  用户可以指定执行某个预设的任务</p></li>
<li><p>Rake supports rule patterns to sythesize implicit tasks.</p>

<p>  Rake 支持规则模式查找任务</p></li>
<li><p>Rake is lightweight. It can be distributed with other projects as a single file. Projects that depend upon rake do not require that rake be installed on target systems.</p>

<p>  Rake 是轻量级的。它可以作为单个文件分发给其他项目。那些依赖于rake的项目并不强制要求rake安装在目标系统上。</p></li>
</ul>


<p><strong>Copyright</strong></p>

<p>Copyright © 2005, by Jim Weirich, Some rights reserved.</p>

<h3>Chapter 1—Introducing Rake</h3>

<p>章节 1 介绍Rake</p>

<h4>Getting Started</h4>

<p>起始</p>

<p><strong>Received via EMail:</strong></p>

<p>收到一些EMail</p>

<blockquote><blockquote><p>I have just started using the excellent Rake tool (thanks, Jim!) and I am at a bit of a loss on how to proceed. I am attempting to   create unit test for some C++ code I am creating, [&#8230;]</p>

<p>我已经开始使用这个Rake工具(感谢Jim), 我花费很多时间去用它。我试图为我的一些C++代码创建unite test&#8230;</p></blockquote></blockquote>

<p>Several people recently have made similar comments, they really like rake, but have had trouble getting started. Although the Rake documentation is fairly complete, it really does assume you are familiar with other build tools such as ant and make. It is not really material for the newbie.</p>

<p>最近有很多人都提到类似的意见，他们真的很喜欢rake，但是他们不知道怎么上手。尽管Rake的文档已经很全面了，但它真的是基于你已经接触过Build家族的其他工具，比如ant和make。所以它也确实不太适合新手。</p>

<p>This tutorial is an attempt to address this lack. We will start with a very simple problem: Building a Simple C Program.</p>

<p>此指南正是弥补这个不足。我们会从一个简单的问题开始：Building 一个简单的C程序</p>

<p><strong>The Problem</strong></p>

<p>We will start with a very simple build problem, the type of problem that make (and now rake) was desiged to deal with.</p>

<p>我们从一个非常简单的build问题入手，这类问题正是make(现在是rake)设计的目的。</p>

<p>Suppose I have a very simple C program consisting of the following files.</p>

<p>比如我有一个非常简单的C程序，有以下一些文件</p>

<figure class='code'><figcaption><span>main.c  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;greet.h&quot;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">greet</span> <span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>greet.h  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">extern</span> <span class="kt">void</span> <span class="n">greet</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">who</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>greet.c  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">greet</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">who</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Hello, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">who</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>(Yes, it really is the old standard “Hello, World” program. I did say we were starting with the basics!)</p>

<p>(是的，这是一个旧式的的“Hello, World”程序。正如我说过的我们从基础开始。)</p>

<p>To compile and run this collection of files, a simple shell script like the following is adequate.</p>

<p>编译并运行这些文件， 使用下面的一个简单的shell脚本</p>

<figure class='code'><figcaption><span>build.sh  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#include &lt;stdio.h&gt;</span>
</span><span class='line'>void greet <span class="o">(</span>const char * who<span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="nb">printf</span> <span class="o">(</span><span class="s2">&quot;Hello, %s\n&quot;</span>, who<span class="o">)</span>;
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>For those not familiar with compiling C code, the cc command is the C compiler. It generates an output file (specified by the -o flag) from the source files listed on the command line.</p>

<p>如果大家不熟悉编译C代码， 命令cc是一个C编译器。在命令行里读取指定的源代码之后生成一个输出文件(使用参数-o)</p>

<p>Running it gives us the following results …</p>

<p>运行它之后我们会得到下面这些结果</p>

<figure class='code'><figcaption><span>output </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ build.sh
</span><span class='line'>$ ./hello
</span><span class='line'>Hello, World</span></code></pre></td></tr></table></div></figure>


<p><strong>Building C Programs</strong></p>

<p>Compiling C programs is really a two step process. First you compile all the source code file into object files. Then you take all the object files and link them together to make the executable.</p>

<p>编译C程序实际上有两步过程。首先你编译所有的源代码文件到对象文章中。然后你再link这些对象文件去创建一个可执行文件。</p>

<p>The following figure illustrates the progression from source files to object files to executable program.</p>

<p>接下来的流程是从源码到对象文件再到可执行程序。</p>

<p>Our program is so small that there is little benefit in doing more than the three line build script above. However, as projects grow, there are more and more source files and object files to manage. Recompiling everything for a simple one line change in a single source file gets old quickly. It is much more efficient to just recompile the few files that change and then relink.</p>

<p>我们的程序小到以至于只用了三行build脚本就可以搞定。然而，随着项目的增长，这里会有更多的源代码文件和对象文件需要管理。在源码中任意一行代码的更改都需要重新编译所有的东西。它必须只去编译那些更改的文件并重新链接才会更有效。</p>

<p>But how do we know what to recompile? Keeping track of that would be quite error prone if we tried to do that by hand. Here is where Rake become useful.</p>

<p>但是我们怎么指导哪些需要重新编译？ 如果我们尝试手动的去跟踪常常会遇到一些错误。这时候Rake就派上用场了。</p>

<p><strong>File Dependencies</strong></p>

<p>文件依赖</p>

<p>First, lets take a look at when files need to be recompiled. Consider the main.o. Obviously if the main.c file changes, then we need to rebuild main.o. But are the other files that can trigger a recompile of main.o?</p>

<p>首先，让我们看看哪些文件需要重新编译的。看一下 main.o，显然的，如果 main.c 文件更改了，那么我们需要重新build main.o。 但是其他的文件也会触发重新编译main.o？</p>

<p>Actually, yes. Looking at the source of main.c, we see that it includes the header file greet.h. That means any changes in greet.h could possibly effect the main.o file as well.</p>

<p>事实上是的。看main.c的源代码，我们看到它包含了一个头文件greet.h。那意味着greet.h的改变也会影响main.o。</p>

<p>We say that main.o has a dependency on the files main.c and greet.h. We can capture this dependency in Rake with the following line:</p>

<p>由此我们可以知道main.o依赖main.c和greet.h。使用Rake我们可以使用一行代码去处理这个依赖问题。</p>

<p><strong>Rakefile Fragment</strong></p>

<p>Rakefile 片段</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">file</span> <span class="s2">&quot;main.o&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.c&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.h&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>The rake dependency declaration is just regular Ruby code. We take advantage of the fact that we can construct hash arguments on the fly, and that Ruby doesn’t require parenthesis around the method arguement to create a file task declaration that reads very naturally to the humans reading the rake file. But its still just Ruby code.</p>

<p>rake依赖定义是一个正常的Ruby代码。实际上我们利用了Ruby的hash结构的参数，并且不需要括号来包裹参数，创建文件任务定义读起来是那么的自然，人性化。 但它的确只是Ruby代码。</p>

<p>Likewise, we can declare the dependencies for creating the “greet.o” file as well.</p>

<p>同样的，我们定义一个创建“greet.o”的依赖关系。</p>

<p><strong>Rakefile Fragment</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">file</span> <span class="s2">&quot;greet.o&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;greet.c&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>greet.c does include stdio.h, but since that is a system header file and not subject to change (often), we can leave itout of the dependency list.</p>

<p>greet.c包含stdio.h，但是系统头文件常常不会变动，我们可以不用再写它的依赖列表。</p>

<p>Finally we can declare the dependencies for the executable program hello. It just depends on the two object files.</p>

<p>最终，我们可以定义可执行文件hello的依赖关系。它只依赖两个对象文件。</p>

<p><strong>Rakefile Fragment</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">file</span> <span class="s2">&quot;hello&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.o&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.o&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice that we only have to declare the direct dependencies of hello. Yes, hello depends on main.o which in turn depends on main.c. But the .c files are not directly used in building hello, so they can safely be omitted from the list.</p>

<p>提醒一下，我们只是定义了hello的直接依赖。hello依赖main.o它又依赖main.c。但是.c源码文件没有直接用来build hello，所以它可以安全的被忽略。</p>

<p><strong>Building the Files</strong></p>

<p>We have carefully specified how the files are related. Now we need to say what Rake would have to do to build the files when needed.</p>

<p>我们仔细的指出这些文件是如何关联的。现在我们需要告诉你当build这些文件的时候rake是怎么工作的。</p>

<p>This part is pretty simple. The three line build script that we started with contains all the commands needed to build the program. We just need to put those actions with the right set of dependencies. Use a Ruby do / end block to capture actions …</p>

<p>这部分相当的简单。这三行build脚本包含了build程序所有的命令。我们只要把它们放在正确的依赖关系上。使用Ruby的 do/end 块去包裹这些指令。</p>

<p>The result looks like this:</p>

<p>结果看上去如下</p>

<p><strong>Rakefile</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="n">file</span> <span class="s1">&#39;main.o&#39;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.c&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.h&quot;</span><span class="o">]</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">sh</span> <span class="s2">&quot;cc -c -o main.o main.c&quot;</span>
</span><span class='line'> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'> <span class="n">file</span> <span class="s1">&#39;greet.o&#39;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s1">&#39;greet.c&#39;</span><span class="o">]</span> <span class="k">do</span>
</span><span class='line'>   <span class="n">sh</span> <span class="s2">&quot;cc -c -o greet.o greet.c&quot;</span>
</span><span class='line'> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">file</span> <span class="s2">&quot;hello&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.o&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.o&quot;</span><span class="o">]</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">sh</span> <span class="s2">&quot;cc -o hello main.o greet.o&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Trying it out</strong></p>

<p>So, let’s see if it works!</p>

<p>然我们看看它是怎么工作的吧。</p>

<p><strong>Output</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rake hello
</span><span class='line'>  <span class="o">(</span>in /home/jim/pgm/rake/intro<span class="o">)</span>
</span><span class='line'>  cc -c -o main.o main.c
</span><span class='line'>  cc -c -o greet.o greet.c
</span><span class='line'>  cc -o hello main.o greet.o
</span></code></pre></td></tr></table></div></figure>


<p>The command line rake hello instructs rake to look through its list of tasks and find one called “hello”. It then checks hello’s dependencies and builds them if required. Finally, when everything is ready it builds hello by executing the C compiler command.</p>

<p>命令rake hello告诉rake去到任务列表中找到一个叫“hello”的任务。然后它检查build hello的依赖关系。最终，准备妥当后执行C编译命令。</p>

<p>Rake dutifully reports what it is doing as it goes along. We can see that each compiler invocation is done in the correct order, building the main program at the end. So, does the program work? Let’s find out.</p>

<p>Rake诚实的报告了它独自做了什么事情。我们看到build main程序从都到尾调用的顺序。</p>

<p><strong>Output</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./hello
</span><span class='line'>Hello, World
</span></code></pre></td></tr></table></div></figure>


<p>Success!</p>

<p>搞定</p>

<p>But what happens when we change a file. Lets change the greet function in greet.c to print “Hi” instead of hello.</p>

<p>但是我们更改了一个文件后会发生什么事情呢？ 我们来修改greet.c文件中的greet方法，用打印“Hi”去替换hello。</p>

<p><strong>Output</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>emacs greet.c
</span><span class='line'><span class="nv">$ </span>rake hello
</span><span class='line'><span class="o">(</span>in /home/jim/pgm/rake/intro<span class="o">)</span>
</span><span class='line'>cc -c -o greet.o greet.c
</span><span class='line'>cc -o hello main.o greet.o
</span><span class='line'><span class="err">$</span>
</span><span class='line'><span class="nv">$ </span>./hello
</span><span class='line'>Hi, World
</span></code></pre></td></tr></table></div></figure>


<p>Notice that it recompiles greet.c making a new greet.o. And then it needs to relink hello with the new greet.o. Then it is done. There is no need to recompile main.c since it never changed.</p>

<p>提示，它重新编译了greet.c去创建新的greet.o。之后，它需要用新的greet.o去重新link hello。这样就完成了。由于main.c没有任何的改变，在这里不需要重新编译。</p>

<p>What do you think will happend if we run Rake again?</p>

<p>你认为重新执行Rake会发生什么事情？</p>

<p><strong>Output</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rake hello
</span><span class='line'><span class="o">(</span>in /home/jim/pgm/rake/intro<span class="o">)</span>
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>That’s right … nothing. Everything is up to date with its dependencies, so there is no work for Rake to do.</p>

<p>哈哈，什么也没发生。所有的都是最新的，所以Rake不需要做任何事情。</p>

<p>Ok, sure. Rake is a bit of overkill for only two source files and a header. But imagine a large project with hundreds of files and dependencies. All of a sudden, a tool like Rake becomes very attractive.</p>

<p>的确，Rake对只有两个源码和一个头文件的项目十分在行。但是，想象一个大项目，有上百个文件和依赖关系，像Rake这样的工具也会非常地受欢迎。</p>

<h4>Summary</h4>

<p>What have we learned? Building a Rakefile involves identifying dependencies and the actions required to create the target files. Then declaring the dependencies and actions are as simple as writing them down in standard Ruby code. Rake then handles the details of building</p>

<p>我们学到了什么呢？创建一个Rakefile，这涉及到识别目标文件的依赖关系和动作, 然后将这些用标准的Ruby代码写到Rakefile中。最后交给Rake去处理building的细节。</p>

<h4>What’s Up Next</h4>

<p>接下来</p>

<p>We notice that even our small example has a bit of duplication in it. We have specify how to compile both C file separately, even though the only difference is the files that are used. The next installment will look at fixing that problem as well as introduce non-file based tasks, rules and file lists.</p>

<p>我们依然会用一个小的示例。我们会指定如何独立地编译C文件，即使是使用上的区别。下面问会解决一些文件无关的任务规则。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Emacs changed my life]]></title>
    <link href="http://tairan.github.com/translator/blog/2012/12/15/how-emacs-changed-my-life/"/>
    <updated>2012-12-15T19:37:00+08:00</updated>
    <id>http://tairan.github.com/translator/blog/2012/12/15/how-emacs-changed-my-life</id>
    <content type="html"><![CDATA[<p>这篇文章是Ruby之父松本行弘(Matz)先生的演讲稿，介绍了Emacs是如何走进并改变他的生活以及为他开发Ruby提供的各种帮助。</p>

<p><a href="http://www.slideshare.net/yukihiro_matz/how-emacs-changed-my-life">原文链接</a> <em>Fuck GFW first</em></p>

<blockquote><blockquote><p>How Emacs changed my life</p>

<p>Yukihiro &#8220;Matz&#8221; Matsumoto
@yukihiro_matz</p></blockquote></blockquote>

<p>Emacs 如何改变了我的生活</p>

<blockquote><blockquote><p>1980</p>

<p>I started programming</p></blockquote></blockquote>

<p>我开始了编程</p>

<p><img src="https://raw.github.com/tairan/translator/master/source/assets/images/2012-12-15/sharp.png" alt="sharp" /></p>

<blockquote><blockquote><p>BASIC</p>

<p>400 steps</p></blockquote></blockquote>

<p>在那个上面用BASIC写了400多条操作</p>

<blockquote><blockquote><p>1988</p>

<p>I met Emacs</p>

<p>On Sun-3</p></blockquote></blockquote>

<p>1988年，在Sun-3上面，我接触了 Emacs</p>

<blockquote><blockquote><p>Shared by 200 undergraduates</p></blockquote></blockquote>

<p>那个机器由200个本科生共享</p>

<blockquote><blockquote><p>I tried Emacs</p>

<p>But I never used</p></blockquote></blockquote>

<p>我尝试了一下Emacs但是并没有使用它</p>

<blockquote><blockquote><p>Emacs was prohibited</p></blockquote></blockquote>

<p>Emacs 是被限制的</p>

<blockquote><blockquote><p>It consumed too much precious memory</p></blockquote></blockquote>

<p>它需要太多的宝贵的内存</p>

<blockquote><blockquote><p>We are free to download free software</p>

<p>We are free to read the source code</p></blockquote></blockquote>

<p>我们可以自由的下载免费自由的软件也可以自由的阅读源代码</p>

<blockquote><blockquote><p>I downloaded Emacs source code</p>

<p>and investigated</p></blockquote></blockquote>

<p>我下载了Emacs源码并研究它</p>

<blockquote><blockquote><p>Emacs was my first Lisp interpreter</p></blockquote></blockquote>

<p>Emacs 是我第一个Lisp直译器</p>

<blockquote><blockquote><p>I learned a lot about language implementation from Emacs</p></blockquote></blockquote>

<p>我从Emacs那里学到了很多关于语言实现的东西</p>

<blockquote><blockquote><p>Embadding integers in pointers</p></blockquote></blockquote>

<p>在指针里嵌入整数</p>

<blockquote><blockquote><p>Mark and sweep garbage collection</p></blockquote></blockquote>

<p>标记和清扫垃圾收集</p>

<blockquote><blockquote><p>Calling convention between Lisp and C</p></blockquote></blockquote>

<p>在Lisp和C之间相互转换调用</p>

<blockquote><blockquote><p>I really understood how Lisp work</p></blockquote></blockquote>

<p>我确实地了解了Lisp是如何工作的</p>

<blockquote><blockquote><p>I was fascinated by Lisp objects</p></blockquote></blockquote>

<p>我沉迷于Lisp的对象</p>

<blockquote><blockquote><p>Lisp objects implemented by C</p></blockquote></blockquote>

<p>Lisp 对象是由C实现的</p>

<blockquote><blockquote><p>Then I got a Sparc Station</p></blockquote></blockquote>

<p>之后我得到一台Sparc工作站</p>

<blockquote><blockquote><p>I started to use Emacs</p></blockquote></blockquote>

<p>我开始使用Emacs了</p>

<blockquote><blockquote><p>Emacs become part of me</p></blockquote></blockquote>

<p>Emacs 成为了我的一部分</p>

<blockquote><blockquote><p>If I didn&#8217;t like anything in Emacs, I could change it</p></blockquote></blockquote>

<p>如果我不喜欢Emacs的哪个部分，我可以修改它</p>

<blockquote><blockquote><p>Emacs is totally configurable</p></blockquote></blockquote>

<p>Emacs是完全可配置的</p>

<blockquote><blockquote><p>Emacs made me realize anything can be changed by a programmer</p></blockquote></blockquote>

<p>Emacs让我意识到作为一名程序员可以改变一切</p>

<blockquote><blockquote><p>It is total freedom</p></blockquote></blockquote>

<p>它完全是自由的</p>

<blockquote><blockquote><p>I could edit without thinking key bindding</p></blockquote></blockquote>

<p>我可以在编辑的时候不用考虑各种组合键绑定</p>

<blockquote><blockquote><p>I didn&#8217;t want to write anything without Emacs</p></blockquote></blockquote>

<p>离开了Emacs我什么都不想写</p>

<blockquote><blockquote><p>Programs, Documents and Mails</p></blockquote></blockquote>

<p>程序，文档以及邮件等</p>

<blockquote><blockquote><p>so I wrote my own mail client</p></blockquote></blockquote>

<p>于是我写了自己的邮件客户端</p>

<blockquote><blockquote><p>named &#8220;cmail&#8221;</p></blockquote></blockquote>

<p>我给他命名叫 &#8220;cmail&#8221;</p>

<blockquote><blockquote><p>in Emacs lisp</p>

<p>It was my first non-trivial (Emacs) Lisp program</p></blockquote></blockquote>

<p>在 Emacs lisp 中，它是我第一个Lisp程序，意味深长。</p>

<blockquote><blockquote><p>I used it everyday</p></blockquote></blockquote>

<p>我每天都在使用它</p>

<blockquote><blockquote><p>1993</p>

<p>I started Ruby development</p></blockquote></blockquote>

<p>1993， 我开始开发Ruby</p>

<blockquote><blockquote><p>with influence from Emacs implementation</p>

<p>Integers are coded in tagged pointers</p>

<p>It uses simple marked sweep garbage collection</p>

<p>It uses similar object model to Lisp</p></blockquote></blockquote>

<p>受Emacs实现的影响，Intergers are coded in tagged pointers (<strong>Could someone help me to translate it?</strong>)</p>

<p>它使用了简单的标记和清扫垃圾收集</p>

<p>它使用了和lisp相似的对象模型</p>

<blockquote><blockquote><p>Then I put Smalltalk-like OO system on top</p></blockquote></blockquote>

<p>之后我在它上层封装了类似 smalltalk 的面向对象系统</p>

<blockquote><blockquote><p>For syntax, I wanted Algol/Ada/Eiffel like one</p></blockquote></blockquote>

<p>语法方面，从Algol/Ada/Eiffel 吸收了一点</p>

<blockquote><blockquote><p>But as an Emacs addict, I needed a language model
作为一个对Emacs重度依赖的人来说，我需要一个language-model</p>

<p>auto-indent was a must</p></blockquote></blockquote>

<p>自动缩进是必须的</p>

<blockquote><blockquote><p>Back to 1993, there was no auto-indenting language mode for a language with such syntax</p></blockquote></blockquote>

<p>回到1993， 还没有一个可以自动缩进的 language-mode 为这样的语法</p>

<blockquote><blockquote><p>So I tried to write experimental ruby-model.el</p></blockquote></blockquote>

<p>所以，我试着写一个 ruby-model.el</p>

<blockquote><blockquote><p>fighting with emacs lisp and regular expression,</p>

<p>for almost whole week</p></blockquote></blockquote>

<p>差不多和emacs lisp以及正则表达式奋战了整整一周</p>

<blockquote><blockquote><p>I somehow succeeded to implement auto-indentation</p>

<p>for a languge with &#8220;end&#8221; delimiters</p></blockquote></blockquote>

<p>我成功的实现了一个可以基于 &#8216;end&#8217; 结尾的自动缩进功能</p>

<blockquote><blockquote><p>If I couldn&#8217;t make ruby-model to work</p></blockquote></blockquote>

<p>如果我不能让 ruby-model 工作起来</p>

<blockquote><blockquote><p>The syntax of Ruby would have changed</p>

<p>to more C-like one</p>

<p>too similar to other scripting languages</p></blockquote></blockquote>

<p>Ruby 的语法也许就要改变的像C一样或者类似其他的脚本语言</p>

<blockquote><blockquote><p>as a result, Ruby would not have gained current popularity</p></blockquote></blockquote>

<p>那样的话，Ruby 也许就不会像现在这样流行了</p>

<blockquote><blockquote><p>Summary</p>

<ol>
<li>Emacs taught me freedom for software</li>
<li>Emacs taught me how to read source code</li>
<li>Emacs taught me power of Lisp</li>
<li>Emacs taught me how to implement a language core</li>
<li>Emacs taught me how to implement a garbage collector</li>
<li>Emacs helped me to code and debug</li>
<li>Emacs helped me to write and edit text/mails/doucments</li>
<li>Emacs helped me to be a effective programmer</li>
<li>Emacs made me a hacker</li>
<li>Emacs has changed my life
forever</li>
</ol>
</blockquote></blockquote>

<p>总结</p>

<ol>
<li>Emacs 告诉我软件的自由</li>
<li>Emasc 告诉我如何阅读源代码</li>
<li>Emacs 告诉我Lisp的强大之处</li>
<li>Emacs 告诉我如何实现一个语言的核心</li>
<li>Emacs 告诉我如何实现一个垃圾收集器</li>
<li>Emacs 帮助我去写代码和调试代码</li>
<li>Emacs 帮助我撰写编辑各种文字，邮件和文档</li>
<li>Emacs 帮助我成为一名高效的程序员</li>
<li>Emasc 塑造我成为一名黑客</li>
<li>Emacs 永远的改变了我的生活</li>
</ol>


<blockquote><blockquote><p>Thank you</p></blockquote></blockquote>

<p>谢谢</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DevDiv TFS Database Sizes]]></title>
    <link href="http://tairan.github.com/translator/blog/2012/12/08/devdiv-tfs-database-sizes/"/>
    <updated>2012-12-08T13:53:00+08:00</updated>
    <id>http://tairan.github.com/translator/blog/2012/12/08/devdiv-tfs-database-sizes</id>
    <content type="html"><![CDATA[<p>这是一篇来自Brian Harry的博客，介绍文章发表时(2009)TFS团队自己的TFS数据库的状况。</p>

<p><a href="http://blogs.msdn.com/b/bharry/archive/2009/05/31/devdiv-tfs-database-sizes.aspx">原文链接</a></p>

<blockquote><p>Someone asked me the other day how big to expect the relative sizes of TFS databases to be.  At the time all I had time to say was “Over time TfsVersionControl will dwarf everything else”.  This weekend, I finally had a few minutes to sit down and do some analysis.  As with all such things, your mileage will vary.  DevDiv is a VERY heavy version control user and this may be a bit disproportionate from what you’ll see but as a system grows, I expect it will start to look more and more like this.</p></blockquote>

<p>有人问我TFS数据库会多大？ 一般我都是回答“随着时间的推移，TfsVersionControl总会显得很壮观&#8221;。 这周末，我终于有点时间坐下来就此做一些分析。每个人的情况会有一些区别。DevDiv是TFS一个很大的用户，并且可能与你看到过的系统增长有些不同。我期望能看到更多彼此的相似之处。</p>

<blockquote><p>Here’s a pie chart that shows you relative sizes:</p></blockquote>

<p>这是一幅数据库大小相关的饼图</p>

<p><img src="http://blogs.msdn.com/blogfiles/bharry/WindowsLiveWriter/DevDivTFSDatabaseSizes_BB10/image_thumb_5.png" alt="a pie chart shows you relatvie sizes" /></p>

<blockquote><p>And here’s the actual numbers:</p></blockquote>

<p>以及一些真实的数据</p>

<p><img src="http://blogs.msdn.com/blogfiles/bharry/WindowsLiveWriter/DevDivTFSDatabaseSizes_BB10/image_thumb_6.png" alt="the actual numbers" /></p>

<blockquote><p>It’s worth looking at how TfsVersionControl breaks down.  Note this won’t match your schema exactly because it is a hybrid TFS 2008/TFS 2010 schema but what I show you will be close.</p></blockquote>

<p>TfsVersionControl很值得去分析一下。 提醒这个和你实际的数据库schema不一致，因为他是一个TFS 2008/TFS 2010的schema混合体，但是他很接近我想要说的意思。</p>

<p><img src="http://blogs.msdn.com/blogfiles/bharry/WindowsLiveWriter/DevDivTFSDatabaseSizes_BB10/image_thumb_3.png" alt="TfsVersionControl Database"></p>

<p><img src="http://blogs.msdn.com/blogfiles/bharry/WindowsLiveWriter/DevDivTFSDatabaseSizes_BB10/image_thumb_4.png" alt="the table's numbers" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello World]]></title>
    <link href="http://tairan.github.com/translator/blog/2012/12/07/hello-world/"/>
    <updated>2012-12-07T13:57:00+08:00</updated>
    <id>http://tairan.github.com/translator/blog/2012/12/07/hello-world</id>
    <content type="html"><![CDATA[<h1>Translator</h1>

<p><strong>Practice, Practice, Practice</strong></p>

<p>For learning English, I try to translate some articles which are my interesting realm, mostly are related to technology, startup, business etc.</p>

<p>if you also like to translate somethings please join me, welcome :)</p>
]]></content>
  </entry>
  
</feed>
