
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Translate somethings</title>
  <meta name="author" content="Tairan Wang">

  
  <meta name="description" content="Rake Tutorial Rake 指南 Rake is a build tool, written in Ruby, using Ruby as a build language. Rake is similar to make in scope and purpose. Rake a &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://tairan.github.com/translator/">
  <link href="/translator/favicon.png" rel="icon">
  <link href="/translator/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/translator/javascripts/modernizr-2.0.js"></script>
  <script src="/translator/javascripts/ender.js"></script>
  <script src="/translator/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/translator/atom.xml" rel="alternate" title="Translate somethings" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-5226610-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/translator/">Translate somethings</a></h1>
  
    <h2>Just for learning English</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/translator/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:tairan.github.com/translator" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/translator/">Blog</a></li>
  <li><a href="/translator/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/translator/blog/2012/12/21/rake-tutorial/">Rake Tutorial</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-21T20:54:00+08:00" pubdate data-updated="true">Dec 21<span>st</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://docs.rubyrake.org/tutorial/index.html">Rake Tutorial</a></p>

<h2>Rake 指南</h2>

<p>Rake is a build tool, written in Ruby, using Ruby as a build language. Rake is similar to make in scope and purpose. Rake a simple ruby build program with capabilities similar to make.</p>

<p>Rake 是用Ruby写的Build工具，使用Ruby作为Build语言。Rake的目标和适用范围和make类似。Rake是一个具有和make类似功能的简单Ruby程序。</p>

<p>Rake has the following features:</p>

<p>Rake 具有一下特征</p>

<ul>
<li><p>Rakefiles (rake’s version of Makefiles) are completely defined in standard Ruby syntax. No XML files to edit. No quirky Makefile syntax to worry about (is that a tab or a space?)</p>

<p>  Rakefiles (Rake版本的Makefiles) 使用完全的标准Ruby语法定义。不用编辑xml文件。没有Makefile的诡异语法问题比如(Tab和空格)</p></li>
<li><p>Users can specify tasks with prerequisites.</p>

<p>  用户可以指定执行预设的任务</p></li>
<li><p>Rake supports rule patterns to sythesize implicit tasks.</p>

<p>  Rake 支持规则模式查找任务</p></li>
<li><p>Rake is lightweight. It can be distributed with other projects as a single file. Projects that depend upon rake do not require that rake be installed on target systems.</p>

<p>  Rake 是轻量级的。它可以在单个文件中分布式处理不同的项目。项目依赖在rake上，不强制要求rake安装在目标系统上。</p></li>
</ul>


<p><strong>Copyright</strong></p>

<p>Copyright © 2005, by Jim Weirich, Some rights reserved.</p>

<h3>Chapter 1—Introducing Rake</h3>

<p>章节 1 介绍Rake</p>

<h4>Getting Started</h4>

<p>起始</p>

<p><strong>Received via EMail:</strong></p>

<p>收到一些EMail</p>

<blockquote><blockquote><p>I have just started using the excellent Rake tool (thanks, Jim!) and I am at a bit of a loss on how to proceed. I am attempting to   create unit test for some C++ code I am creating, [&#8230;]</p>

<p>我正好开始使用Rake工具(感谢Jim), 我花费很多时间去处理。我去创建我为C++代码创建unite test，创建&#8230;</p></blockquote></blockquote>

<p>Several people recently have made similar comments, they really like rake, but have had trouble getting started. Although the Rake documentation is fairly complete, it really does assume you are familiar with other build tools such as ant and make. It is not really material for the newbie.</p>

<p>很多人都有类似的意见，他们这的很喜欢rake，但是他们不知道怎么上手。通过完整的Rake文档，它真的和你接触到的Build工具是同一家族的，比如ant和make。它也确实不太适合新手。</p>

<p>This tutorial is an attempt to adderess this lack. We will start with a very simple problem: Building a Simple C Program.</p>

<p>此指南正是弥补这个不足。我们会从一个简单的问题开始：Building 一个简单的C程序</p>

<p><strong>The Problem</strong></p>

<p>We will start with a very simple build problem, the type of problem that make (and now rake) was desiged to deal with.</p>

<p>我们从一个非常简单的build问题入手，这类问题正是make(现在是rake)设计的目的。</p>

<p>Suppose I have a very simple C program consisting of the following files.</p>

<p>比如我有一个非常简单的C程序，有以下一些文件</p>

<figure class='code'><figcaption><span>main.c  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;greet.h&quot;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">greet</span> <span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>greet.h  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">extern</span> <span class="kt">void</span> <span class="n">greet</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">who</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>greet.c  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">greet</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">who</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Hello, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">who</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>(Yes, it really is the old standard “Hello, World” program. I did say we were starting with the basics!)</p>

<p>(是的，这是一个旧式的的“Hello, World”程序。正如我说过的我们从基础开始。)</p>

<p>To compile and run this collection of files, a simple shell script like the following is adequate.</p>

<p>编译并运行这些文件， 使用下面的一个简单的shell脚本</p>

<figure class='code'><figcaption><span>build.sh  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#include &lt;stdio.h&gt;</span>
</span><span class='line'>void greet <span class="o">(</span>const char * who<span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="nb">printf</span> <span class="o">(</span><span class="s2">&quot;Hello, %s\n&quot;</span>, who<span class="o">)</span>;
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>For those not familiar with compiling C code, the cc command is the C compiler. It generates an output file (specified by the -o flag) from the source files listed on the command line.</p>

<p>如果大家不熟悉编译C代码， 命令cc是一个C编译器。在命令行里读取指定的源代码之后生成一个输出文件(使用参数-o)</p>

<p>Running it gives us the following results …</p>

<p>运行它之后我们会得到下面这些结果</p>

<figure class='code'><figcaption><span>output </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ build.sh
</span><span class='line'>$ ./hello
</span><span class='line'>Hello, World</span></code></pre></td></tr></table></div></figure>


<p><strong>Building C Programs</strong></p>

<p>Compiling C programs is really a two step process. First you compile all the source code file into object files. Then you take all the object files and link them together to make the executable.</p>

<p>编译C程序实际上有两步过程。首先你编译所有的源代码文件到对象文章中。然后你再link这些对象文件去创建一个可执行文件。</p>

<p>The following figure illustrates the progression from source files to object files to executable program.</p>

<p>接下来的流程是从源码到对象文件再到可执行程序。</p>

<p>Our program is so small that there is little benefit in doing more than the three line build script above. However, as projects grow, there are more and more source files and object files to manage. Recompiling everything for a simple one line change in a single source file gets old quickly. It is much more efficient to just recompile the few files that change and then relink.</p>

<p>我们的程序很小，只用了上面三行build脚本就搞定了。然而，随着项目的增长，这里会有更多的源代码文件和对象文件需要管理。在源码中任意一行代码的更改都需要重新编译所有的东西。它必须只去编译和链接那些更改的文件。</p>

<p>But how do we know what to recompile? Keeping track of that would be quite error prone if we tried to do that by hand. Here is where Rake become useful.</p>

<p>但是我们怎么指导哪些需要重新编译？ 如果我们尝试手动的去跟踪常常会遇到一些错误。这时候Rake就派上用场了。</p>

<p><strong>File Dependencies</strong></p>

<p>文件依赖</p>

<p>First, lets take a look at when files need to be recompiled. Consider the main.o. Obviously if the main.c file changes, then we need to rebuild main.o. But are the other files that can trigger a recompile of main.o?</p>

<p>首先，让我们看看哪些文件需要重新编译的。看一下 main.o，显然的，如果 main.c 文件更改了，那么我们需要重新build main.o。 但是其他的文件也会触发重新编译main.o？</p>

<p>Actually, yes. Looking at the source of main.c, we see that it includes the header file greet.h. That means any changes in greet.h could possibly effect the main.o file as well.</p>

<p>事实上是的。看main.c的源代码，我们看到它包含了一个头文件greet.h。那意味着greet.h的改变也会影响main.o。</p>

<p>We say that main.o has a dependency on the files main.c and greet.h. We can capture this dependency in Rake with the following line:</p>

<p>由此我们可以知道main.o依赖main.c和greet.h。使用Rake我们可以使用一行代码去处理这个依赖问题。</p>

<p><strong>Rakefile Fragment</strong></p>

<p>Rakefile 片段</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">file</span> <span class="s2">&quot;main.o&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.c&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.h&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>The rake dependency declaration is just regular Ruby code. We take advantage of the fact that we can construct hash arguments on the fly, and that Ruby doesn’t require parenthesis around the method arguement to create a file task declaration that reads very naturally to the humans reading the rake file. But its still just Ruby code.</p>

<p>rake依赖定义是一个正常的Ruby代码。实际上我们利用hash的参数结构，Ruby不需要括号来包裹方法的参数，创建文件任务定义读起来是那么的自然，可度性很高。 但是它只是Ruby代码。</p>

<p>Likewise, we can declare the dependencies for creating the “greet.o” file as well.</p>

<p>同样的，我们定义一个创建“greet.o”的依赖关系。</p>

<p><strong>Rakefile Fragment</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">file</span> <span class="s2">&quot;greet.o&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;greet.c&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>greet.c does include stdio.h, but since that is a system header file and not subject to change (often), we can leave itout of the dependency list.</p>

<p>greet.c包含stdio.h，但是系统头文件常常不会变动，我们可以不用再写它的依赖列表。</p>

<p>Finally we can declare the dependencies for the executable program hello. It just depends on the two object files.</p>

<p>最终，我们可以定义可执行文件hello的依赖关系。它只依赖两个对象文件。</p>

<p><strong>Rakefile Fragment</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">file</span> <span class="s2">&quot;hello&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.o&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.o&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice that we only have to declare the direct dependencies of hello. Yes, hello depends on main.o which in turn depends on main.c. But the .c files are not directly used in building hello, so they can safely be omitted from the list.</p>

<p>提醒一下，我们只是定义了hello的直接依赖。hello依赖main.o它又依赖main.c。但是.c源码文件没有直接用来build hello，所以它可以安全的被忽略。</p>

<p><strong>Building the Files</strong></p>

<p>We have carefully specified how the files are related. Now we need to say what Rake would have to do to build the files when needed.</p>

<p>我们仔细的指定这些文件是如何关联的。现在我们需要说rake是怎么去build这些文件的。</p>

<p>This part is pretty simple. The three line build script that we started with contains all the commands needed to build the program. We just need to put those actions with the right set of dependencies. Use a Ruby do / end block to capture actions …</p>

<p>这部分相当的简单。这三行build脚本包含了build程序所有的命令。我们只要把它们放在正确的依赖关系上。使用Ruby的 do/end 块去包裹这些指令。</p>

<p>The result looks like this:</p>

<p>结果看上去如下</p>

<p><strong>Rakefile</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="n">file</span> <span class="s1">&#39;main.o&#39;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.c&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.h&quot;</span><span class="o">]</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">sh</span> <span class="s2">&quot;cc -c -o main.o main.c&quot;</span>
</span><span class='line'> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'> <span class="n">file</span> <span class="s1">&#39;greet.o&#39;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s1">&#39;greet.c&#39;</span><span class="o">]</span> <span class="k">do</span>
</span><span class='line'>   <span class="n">sh</span> <span class="s2">&quot;cc -c -o greet.o greet.c&quot;</span>
</span><span class='line'> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">file</span> <span class="s2">&quot;hello&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.o&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.o&quot;</span><span class="o">]</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">sh</span> <span class="s2">&quot;cc -o hello main.o greet.o&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Trying it out</strong></p>

<p>So, let’s see if it works!</p>

<p>然我们看看它是怎么工作的吧。</p>

<p><strong>Output</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rake hello
</span><span class='line'>  <span class="o">(</span>in /home/jim/pgm/rake/intro<span class="o">)</span>
</span><span class='line'>  cc -c -o main.o main.c
</span><span class='line'>  cc -c -o greet.o greet.c
</span><span class='line'>  cc -o hello main.o greet.o
</span></code></pre></td></tr></table></div></figure>


<p>The command line rake hello instructs rake to look through its list of tasks and find one called “hello”. It then checks hello’s dependencies and builds them if required. Finally, when everything is ready it builds hello by executing the C compiler command.</p>

<p>命令rake hello告诉rake去到任务列表中找到一个叫“hello”的任务。然后它检查build hello的依赖关系。最终，准备妥当后执行C编译命令。</p>

<p>Rake dutifully reports what it is doing as it goes along. We can see that each compiler invocation is done in the correct order, building the main program at the end. So, does the program work? Let’s find out.</p>

<p>Rake诚实的报告了它独自做了什么事情。我们看到build main程序从都到尾调用的顺序。</p>

<p><strong>Output</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./hello
</span><span class='line'>Hello, World
</span></code></pre></td></tr></table></div></figure>


<p>Success!</p>

<p>搞定</p>

<p>But what happens when we change a file. Lets change the greet function in greet.c to print “Hi” instead of hello.</p>

<p>但是我们更改了一个文件后会发生什么事情呢？ 我们来修改greet.c文件中的greet方法，用打印“Hi”去替换hello。</p>

<p><strong>Output</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>emacs greet.c
</span><span class='line'><span class="nv">$ </span>rake hello
</span><span class='line'><span class="o">(</span>in /home/jim/pgm/rake/intro<span class="o">)</span>
</span><span class='line'>cc -c -o greet.o greet.c
</span><span class='line'>cc -o hello main.o greet.o
</span><span class='line'><span class="err">$</span>
</span><span class='line'><span class="nv">$ </span>./hello
</span><span class='line'>Hi, World
</span></code></pre></td></tr></table></div></figure>


<p>Notice that it recompiles greet.c making a new greet.o. And then it needs to relink hello with the new greet.o. Then it is done. There is no need to recompile main.c since it never changed.</p>

<p>提示，它重新编译了greet.c去创建新的greet.o。之后，它需要用新的greet.o去重新link hello。这样就完成了。由于main.c没有任何的改变，在这里不需要重新编译。</p>

<p>What do you think will happend if we run Rake again?</p>

<p>你认为重新执行Rake会发生什么事情？</p>

<p><strong>Output</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rake hello
</span><span class='line'><span class="o">(</span>in /home/jim/pgm/rake/intro<span class="o">)</span>
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>That’s right … nothing. Everything is up to date with its dependencies, so there is no work for Rake to do.</p>

<p>哈哈，什么也没发生。所有的都是最新的，所以Rake不需要做任何事情。</p>

<p>Ok, sure. Rake is a bit of overkill for only two source files and a header. But imagine a large project with hundreds of files and dependencies. All of a sudden, a tool like Rake becomes very attractive.</p>

<p>的确，Rake对只有两个源码和一个头文件的项目十分在行。但是，想象一个大项目，有上百个文件和依赖关系，像Rake这样的工具也会非常地受欢迎。</p>

<h4>Summary</h4>

<p>What have we learned? Building a Rakefile involves identifying dependencies and the actions required to create the target files. Then declaring the dependencies and actions are as simple as writing them down in standard Ruby code. Rake then handles the details of building</p>

<p>我们学到了什么？Building一个Rakefile，去识别创建目标文件的依赖关系和动作。然后用标准的Rbuy代码去定义和处理这些依赖和动作。Rake去处理building的细节。</p>

<h4>What’s Up Next</h4>

<p>接下来</p>

<p>We notice that even our small example has a bit of duplication in it. We have specify how to compile both C file separately, even though the only difference is the files that are used. The next installment will look at fixing that problem as well as introduce non-file based tasks, rules and file lists.</p>

<p>我们依然会用一个小的示例。我们会指定如何独立地编译C文件，即使是使用上的区别。下面问会解决一些文件无关的任务规则。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/translator/blog/2012/12/15/how-emacs-changed-my-life/">How Emacs Changed My Life</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-15T19:37:00+08:00" pubdate data-updated="true">Dec 15<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这篇文章是Ruby之父松本行弘(Matz)先生的演讲稿，介绍了Emacs是如何走进并改变他的生活以及为他开发Ruby提供的各种帮助。</p>

<p><a href="http://www.slideshare.net/yukihiro_matz/how-emacs-changed-my-life">原文链接</a> <em>Fuck GFW first</em></p>

<blockquote><blockquote><p>How Emacs changed my life</p>

<p>Yukihiro &#8220;Matz&#8221; Matsumoto
@yukihiro_matz</p></blockquote></blockquote>

<p>Emacs 如何改变了我的生活</p>

<blockquote><blockquote><p>1980</p>

<p>I started programming</p></blockquote></blockquote>

<p>我开始了编程</p>

<p><img src="https://raw.github.com/tairan/translator/master/source/assets/images/2012-12-15/sharp.png" alt="sharp" /></p>

<blockquote><blockquote><p>BASIC</p>

<p>400 steps</p></blockquote></blockquote>

<p>在那个上面用BASIC写了400多条操作</p>

<blockquote><blockquote><p>1988</p>

<p>I met Emacs</p>

<p>On Sun-3</p></blockquote></blockquote>

<p>1988年，在Sun-3上面，我接触了 Emacs</p>

<blockquote><blockquote><p>Shared by 200 undergraduates</p></blockquote></blockquote>

<p>那个机器由200个本科生共享</p>

<blockquote><blockquote><p>I tried Emacs</p>

<p>But I never used</p></blockquote></blockquote>

<p>我尝试了一下Emacs但是并没有使用它</p>

<blockquote><blockquote><p>Emacs was prohibited</p></blockquote></blockquote>

<p>Emacs 是被限制的</p>

<blockquote><blockquote><p>It consumed too much precious memory</p></blockquote></blockquote>

<p>它需要太多的宝贵的内存</p>

<blockquote><blockquote><p>We are free to download free software</p>

<p>We are free to read the source code</p></blockquote></blockquote>

<p>我们可以自由的下载免费自由的软件也可以自由的阅读源代码</p>

<blockquote><blockquote><p>I downloaded Emacs source code</p>

<p>and investigated</p></blockquote></blockquote>

<p>我下载了Emacs源码并研究它</p>

<blockquote><blockquote><p>Emacs was my first Lisp interpreter</p></blockquote></blockquote>

<p>Emacs 是我第一个Lisp直译器</p>

<blockquote><blockquote><p>I learned a lot about language implementation from Emacs</p></blockquote></blockquote>

<p>我从Emacs那里学到了很多关于语言实现的东西</p>

<blockquote><blockquote><p>Embadding integers in pointers</p></blockquote></blockquote>

<p>在指针里嵌入整数</p>

<blockquote><blockquote><p>Mark and sweep garbage collection</p></blockquote></blockquote>

<p>标记和清扫垃圾收集</p>

<blockquote><blockquote><p>Calling convention between Lisp and C</p></blockquote></blockquote>

<p>在Lisp和C之间相互转换调用</p>

<blockquote><blockquote><p>I really understood how Lisp work</p></blockquote></blockquote>

<p>我确实地了解了Lisp是如何工作的</p>

<blockquote><blockquote><p>I was fascinated by Lisp objects</p></blockquote></blockquote>

<p>我沉迷于Lisp的对象</p>

<blockquote><blockquote><p>Lisp objects implemented by C</p></blockquote></blockquote>

<p>Lisp 对象是由C实现的</p>

<blockquote><blockquote><p>Then I got a Sparc Station</p></blockquote></blockquote>

<p>之后我得到一台Sparc工作站</p>

<blockquote><blockquote><p>I started to use Emacs</p></blockquote></blockquote>

<p>我开始使用Emacs了</p>

<blockquote><blockquote><p>Emacs become part of me</p></blockquote></blockquote>

<p>Emacs 成为了我的一部分</p>

<blockquote><blockquote><p>If I didn&#8217;t like anything in Emacs, I could change it</p></blockquote></blockquote>

<p>如果我不喜欢Emacs的哪个部分，我可以修改它</p>

<blockquote><blockquote><p>Emacs is totally configurable</p></blockquote></blockquote>

<p>Emacs是完全可配置的</p>

<blockquote><blockquote><p>Emacs made me realize anything can be changed by a programmer</p></blockquote></blockquote>

<p>Emacs让我意识到作为一名程序员可以改变一切</p>

<blockquote><blockquote><p>It is total freedom</p></blockquote></blockquote>

<p>它完全是自由的</p>

<blockquote><blockquote><p>I could edit without thinking key bindding</p></blockquote></blockquote>

<p>我可以在编辑的时候不用考虑各种组合键绑定</p>

<blockquote><blockquote><p>I didn&#8217;t want to write anything without Emacs</p></blockquote></blockquote>

<p>离开了Emacs我什么都不想写</p>

<blockquote><blockquote><p>Programs, Documents and Mails</p></blockquote></blockquote>

<p>程序，文档以及邮件等</p>

<blockquote><blockquote><p>so I wrote my own mail client</p></blockquote></blockquote>

<p>于是我写了自己的邮件客户端</p>

<blockquote><blockquote><p>named &#8220;cmail&#8221;</p></blockquote></blockquote>

<p>我给他命名叫 &#8220;cmail&#8221;</p>

<blockquote><blockquote><p>in Emacs lisp</p>

<p>It was my first non-trivial (Emacs) Lisp program</p></blockquote></blockquote>

<p>在 Emacs lisp 中，它是我第一个Lisp程序，意味深长。</p>

<blockquote><blockquote><p>I used it everyday</p></blockquote></blockquote>

<p>我每天都在使用它</p>

<blockquote><blockquote><p>1993</p>

<p>I started Ruby development</p></blockquote></blockquote>

<p>1993， 我开始开发Ruby</p>

<blockquote><blockquote><p>with influence from Emacs implementation</p>

<p>Integers are coded in tagged pointers</p>

<p>It uses simple marked sweep garbage collection</p>

<p>It uses similar object model to Lisp</p></blockquote></blockquote>

<p>受Emacs实现的影响，Intergers are coded in tagged pointers (<strong>Could someone help me to translate it?</strong>)</p>

<p>它使用了简单的标记和清扫垃圾收集</p>

<p>它使用了和lisp相似的对象模型</p>

<blockquote><blockquote><p>Then I put Smalltalk-like OO system on top</p></blockquote></blockquote>

<p>之后我在它上层封装了类似 smalltalk 的面向对象系统</p>

<blockquote><blockquote><p>For syntax, I wanted Algol/Ada/Eiffel like one</p></blockquote></blockquote>

<p>语法方面，从Algol/Ada/Eiffel 吸收了一点</p>

<blockquote><blockquote><p>But as an Emacs addict, I needed a language model
作为一个对Emacs重度依赖的人来说，我需要一个language-model</p>

<p>auto-indent was a must</p></blockquote></blockquote>

<p>自动缩进是必须的</p>

<blockquote><blockquote><p>Back to 1993, there was no auto-indenting language mode for a language with such syntax</p></blockquote></blockquote>

<p>回到1993， 还没有一个可以自动缩进的 language-mode 为这样的语法</p>

<blockquote><blockquote><p>So I tried to write experimental ruby-model.el</p></blockquote></blockquote>

<p>所以，我试着写一个 ruby-model.el</p>

<blockquote><blockquote><p>fighting with emacs lisp and regular expression,</p>

<p>for almost whole week</p></blockquote></blockquote>

<p>差不多和emacs lisp以及正则表达式奋战了整整一周</p>

<blockquote><blockquote><p>I somehow succeeded to implement auto-indentation</p>

<p>for a languge with &#8220;end&#8221; delimiters</p></blockquote></blockquote>

<p>我成功的实现了一个可以基于 &#8216;end&#8217; 结尾的自动缩进功能</p>

<blockquote><blockquote><p>If I couldn&#8217;t make ruby-model to work</p></blockquote></blockquote>

<p>如果我不能让 ruby-model 工作起来</p>

<blockquote><blockquote><p>The syntax of Ruby would have changed</p>

<p>to more C-like one</p>

<p>too similar to other scripting languages</p></blockquote></blockquote>

<p>Ruby 的语法也许就要改变的像C一样或者类似其他的脚本语言</p>

<blockquote><blockquote><p>as a result, Ruby would not have gained current popularity</p></blockquote></blockquote>

<p>那样的话，Ruby 也许就不会像现在这样流行了</p>

<blockquote><blockquote><p>Summary</p>

<ol>
<li>Emacs taught me freedom for software</li>
<li>Emacs taught me how to read source code</li>
<li>Emacs taught me power of Lisp</li>
<li>Emacs taught me how to implement a language core</li>
<li>Emacs taught me how to implement a garbage collector</li>
<li>Emacs helped me to code and debug</li>
<li>Emacs helped me to write and edit text/mails/doucments</li>
<li>Emacs helped me to be a effective programmer</li>
<li>Emacs made me a hacker</li>
<li>Emacs has changed my life
forever</li>
</ol>
</blockquote></blockquote>

<p>总结</p>

<ol>
<li>Emacs 告诉我软件的自由</li>
<li>Emasc 告诉我如何阅读源代码</li>
<li>Emacs 告诉我Lisp的强大之处</li>
<li>Emacs 告诉我如何实现一个语言的核心</li>
<li>Emacs 告诉我如何实现一个垃圾收集器</li>
<li>Emacs 帮助我去写代码和调试代码</li>
<li>Emacs 帮助我撰写编辑各种文字，邮件和文档</li>
<li>Emacs 帮助我成为一名高效的程序员</li>
<li>Emasc 塑造我成为一名黑客</li>
<li>Emacs 永远的改变了我的生活</li>
</ol>


<blockquote><blockquote><p>Thank you</p></blockquote></blockquote>

<p>谢谢</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/translator/blog/2012/12/08/devdiv-tfs-database-sizes/">DevDiv TFS Database Sizes</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-08T13:53:00+08:00" pubdate data-updated="true">Dec 8<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这是一篇来自Brian Harry的博客，介绍文章发表时(2009)TFS团队自己的TFS数据库的状况。</p>

<p><a href="http://blogs.msdn.com/b/bharry/archive/2009/05/31/devdiv-tfs-database-sizes.aspx">原文链接</a></p>

<blockquote><p>Someone asked me the other day how big to expect the relative sizes of TFS databases to be.  At the time all I had time to say was “Over time TfsVersionControl will dwarf everything else”.  This weekend, I finally had a few minutes to sit down and do some analysis.  As with all such things, your mileage will vary.  DevDiv is a VERY heavy version control user and this may be a bit disproportionate from what you’ll see but as a system grows, I expect it will start to look more and more like this.</p></blockquote>

<p>有人问我TFS数据库会多大？ 一般我都是回答“随着时间的推移，TfsVersionControl总会显得很壮观&#8221;。 这周末，我终于有点时间坐下来就此做一些分析。每个人的情况会有一些区别。DevDiv是TFS一个很大的用户，并且可能与你看到过的系统增长有些不同。我期望能看到更多彼此的相似之处。</p>

<blockquote><p>Here’s a pie chart that shows you relative sizes:</p></blockquote>

<p>这是一幅数据库大小相关的饼图</p>

<p><img src="http://blogs.msdn.com/blogfiles/bharry/WindowsLiveWriter/DevDivTFSDatabaseSizes_BB10/image_thumb_5.png" alt="a pie chart shows you relatvie sizes" /></p>

<blockquote><p>And here’s the actual numbers:</p></blockquote>

<p>以及一些真实的数据</p>

<p><img src="http://blogs.msdn.com/blogfiles/bharry/WindowsLiveWriter/DevDivTFSDatabaseSizes_BB10/image_thumb_6.png" alt="the actual numbers" /></p>

<blockquote><p>It’s worth looking at how TfsVersionControl breaks down.  Note this won’t match your schema exactly because it is a hybrid TFS 2008/TFS 2010 schema but what I show you will be close.</p></blockquote>

<p>TfsVersionControl很值得去分析一下。 提醒这个和你实际的数据库schema不一致，因为他是一个TFS 2008/TFS 2010的schema混合体，但是他很接近我想要说的意思。</p>

<p><img src="http://blogs.msdn.com/blogfiles/bharry/WindowsLiveWriter/DevDivTFSDatabaseSizes_BB10/image_thumb_3.png" alt="TfsVersionControl Database"></p>

<p><img src="http://blogs.msdn.com/blogfiles/bharry/WindowsLiveWriter/DevDivTFSDatabaseSizes_BB10/image_thumb_4.png" alt="the table's numbers" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/translator/blog/2012/12/07/hello-world/">Hello World</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-07T13:57:00+08:00" pubdate data-updated="true">Dec 7<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Translator</h1>

<p><strong>Practice, Practice, Practice</strong></p>

<p>For learning English, I try to translate some articles which are my interesting realm, mostly are related to technology, startup, business etc.</p>

<p>if you also like to translate somethings please join me, welcome :)</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/translator/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/translator/blog/2012/12/21/rake-tutorial/">Rake Tutorial</a>
      </li>
    
      <li class="post">
        <a href="/translator/blog/2012/12/15/how-emacs-changed-my-life/">How Emacs changed my life</a>
      </li>
    
      <li class="post">
        <a href="/translator/blog/2012/12/08/devdiv-tfs-database-sizes/">DevDiv TFS Database Sizes</a>
      </li>
    
      <li class="post">
        <a href="/translator/blog/2012/12/07/hello-world/">Hello World</a>
      </li>
    
  </ul>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Tairan Wang -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'tairan';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
