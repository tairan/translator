
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Translate somethings</title>
  <meta name="author" content="Tairan Wang">

  
  <meta name="description" content="Rake Tutorial Chapter 2—Managing Files with FileLists Handling Common Actions 处理通用动作 Rake is a tool for controlling builds. In this part of the Rake &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://tairan.github.com/translator/">
  <link href="/translator/favicon.png" rel="icon">
  <link href="/translator/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/translator/javascripts/modernizr-2.0.js"></script>
  <script src="/translator/javascripts/ender.js"></script>
  <script src="/translator/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/translator/atom.xml" rel="alternate" title="Translate somethings" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-5226610-2']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/translator/">Translate somethings</a></h1>
  
    <h2>Just for learning English</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/translator/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:tairan.github.com/translator" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/translator/">Blog</a></li>
  <li><a href="/translator/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/translator/blog/2013/01/04/rake-tutorial-2/">Rake Tutorial 2</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-04T14:38:00+08:00" pubdate data-updated="true">Jan 4<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://docs.rubyrake.org/tutorial/chapter02.html">Rake Tutorial</a></p>

<h2>Chapter 2—Managing Files with FileLists</h2>

<p>Handling Common Actions</p>

<p>处理通用动作</p>

<blockquote><p>Rake is a tool for controlling builds. In this part of the Rake tutorial, we see how to organize the Rake actions to apply to many similar tasks.</p>

<p>Rake 是一个用来控制build的工具。在此指南的这部分，我们去看如何组织Rake动作并应用到相似的任务中去。</p>

<p>In the previous chapter, we talked about the basics of specifying dependencies and associating actions to build the files. We ended up with a nice Rakefile that built our simple C program, but with some duplication in the build rules.</p>

<p>在前一个章节中，我们谈论了关于去构建Rakefile用到特定依赖和关联行为的基本知识。最后我们有了一个不错的用来build我们简单的C程序的Rakefile，但是在build规则中有一些重复。</p></blockquote>

<p>But First, Some Extra Rake Targets</p>

<p>首先，一些额外的Rake目标</p>

<p>But before we get into all that, lets add some convience targets to our Rakefile. First of all, it would be nice to have a default target that is invoked when we don’t give any explicit task names to rake. The default target looks like this:</p>

<p>在我们深入开始之前，让我们为Rakefile添加一些切实可行的目标。首先，当我们没有为rake明确声明任务名称时，它会被作为默认的目标被调用。这个默认的目标如下</p>

<p>Rakefile Fragment</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">task</span> <span class="ss">:default</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;hello&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Until now, the only kind of task we have seen in Rake are file tasks. File tasks are knowledgable about time stamps on files. A file task will not execute its action unless the file it represents doesn’t exist, or is older than any of its prerequisites.</p>

<p>直到现在，在Rake中我们看到的唯一的任务类型是file tasks。File tasks很擅长于文件上的时间戳处理。 除非file task代表它不存在，或者比它要求的时间更旧，否则file task不会执行这个动作。</p>

<p>A non-file task (or just plain “task”) does not represent the creation of a file. Since there is no timestamp for comparison, non-file tasks always execute their actions (if they have any). Since the default task does not represent a file named “default”, we use a regular non-file task for this purpose. Non-file tasks just use the task keyword (instead of the file keyword).</p>

<p>一个非文件任务(或只是简单的“task”) 并不代表创建一个文件。因为这里没有时间戳用来比对，所以非文件任务总是执行这些动作(如果它有的话)。默认的任务不代表一个叫“default”的文件，为了这个目的，我们使用一个非文件任务。非文件任务只是用任务关键字。（替代file关键字）</p>

<p>Here are a couple of other really useful tasks that I almost always include in a Rakefile.</p>

<p>这里有一组真实有用的任务，我通常总会将他们包含在Rakefile中。</p>

<p>clean:</p>

<pre><code>Remove temporary files created during the build process.
</code></pre>

<p>清理:</p>

<pre><code>移除在build过程期间创建的临时文件。
</code></pre>

<p>clobber:</p>

<pre><code>Remove **all** files generated during the build process.
</code></pre>

<p>clobber:</p>

<pre><code>移除所有在build过程期间生成的文件。
</code></pre>

<p>clean tidies up the directories and removes any files that generated as part of the build process, but are not the final goal of the build process. For example, the .o files used to link up the final executable hello program would fall in this category. After the executable program is built, the .o files are no longer needed and will be removed by saying “rake clean”.</p>

<p>整理目录，并且清理在build处理期间生成的文件，但不是build流程最终的目标结果。例如： 用来link最终可执行程序的.o 文件都归为这类。 在可执行程序build完成之后，.o 文件就不再需要了，把它们移除掉可以称为&#8221;rake clean&#8221;。</p>

<p>clobber is like clean, but even more aggressive. “rake clobber” will remove all files that are not part of the original package. It should return a project to the “just checked out of CVS” state. So it removes the final executable program as well as the files removed by clean.</p>

<p>colbber类似clean，但是更具有侵略性. &#8220;rake colbber&#8221;会移除所有不是原包中的所有文件。它会回到“刚刚从cvs中checkout”的状态。因此它会做clean相关的移除外还会删除最终的可执行程序。</p>

<p>In fact, these tasks are so common, Rake comes with a predefined library that implements clean and clobber.</p>

<p>实际上，这些任务是如此的通用，Rake有预定义的库来实现清理和clobber.</p>

<p>But every project is different, how do we specify which files are to be cleaned and clobbered on a per project basis?</p>

<p>但是每个项目的都不尽相同，我们怎么为每个项目指定哪些文件需要被清理和clobbered呢？</p>

<p>The answer is File lists.</p>

<p>答案是，文件列表。</p>

<p>File Lists to the Rescue</p>

<p>文件列表去拯救</p>

<p>A file list is simply a list of file names. Since a lot of what Rake does involves files and lists of those files, a file list has some special features to make manipulating file names rather easy.</p>

<p>文件列表是一个简单的文件名字的列表。因为Rake做的很多事情是调用文件和那些文件的列表，所以这个文件列表具有一些特征使处理文件名更容易。</p>

<p>Suppose you want a list of all the C files in your project. You could add this to your rake file:</p>

<p>假如你想要一个在你项目中所有C文件的列表。你可以增加下面的代码在你的Rakefile中。</p>

<p>Rakefile Fragment</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SRC</span> <span class="o">=</span> <span class="no">FileList</span><span class="o">[</span><span class="s1">&#39;*.c&#39;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>This will collect all the files ending in ”.c” in the top level directory of your project. File lists understand glob patterns (i.e. things like &#8220;.c&#8221;) and will find all the matching files.</p>

<p>这会手机你项目中顶级目录中文件名以&#8221;.c&#8221;结尾的文件。文件列表支持glob模式。(i.e. 比如 &#8220;.c&#8221;)并且会找到所有符合的文件。</p>

<p>By the way, no matter where you invoke it, rake always executes in the directory where the Rakefile is found. This keeps your path names consistent without depending on the current directory the user interactive shell.</p>

<p>顺便提一下, 无论你在什么地方调用它, rake总是在Rakefile所在的目录中执行。这能保证你在shell中不会依赖当前目录。</p>

<p>The clean and clobber tasks use file lists to manage the files to remove. So if we want to clean up all the .o files in a project we could try …</p>

<p>清理和clobber任务使用文件列表来管理哪些文件被移除。因此如果我们需要清理项目中的所有.o文件，可以试一下..</p>

<p>Rakefile Fragment*</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">CLEAN</span> <span class="o">=</span> <span class="no">FileList</span><span class="o">[</span><span class="s1">&#39;*.o&#39;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>(CLEAN is the file list associated with the clean task. I’ll let you guess the name of the file list associated with clobber).</p>

<p>(CLEAN 是关联到清理任务的文件列表。 我会让你猜一下关联到clobber任务的文件列表名字)</p>

<h2>Chapter 3—Reducing Duplication with Rules</h2>

<p>Dynamically Building Tasks</p>

<p>动态的Building任务</p>

<p>The command to compile the main.c and greet.c files is identical, except for the name of the files involved. The simpliest and most direct way to address the problem is to define the compile task in a loop. Perhaps something like this …</p>

<p>编译 main.c 和 greet.c 文件的命令是完全一致的，除了被调用的文件名。最简单直接的方式去处理这个问题是在一个循环中定义编译任务。示例</p>

<p>Rakefile Fragment</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">SRC</span> <span class="o">=</span> <span class="no">FileList</span><span class="o">[</span><span class="s1">&#39;*.c&#39;</span><span class="o">]</span>
</span><span class='line'><span class="no">SRC</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">fn</span><span class="o">|</span>
</span><span class='line'>  <span class="n">obj</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sr">/\.[^.]*$/</span><span class="p">,</span> <span class="s1">&#39;.o&#39;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">file</span> <span class="n">obj</span>  <span class="k">do</span>
</span><span class='line'>    <span class="n">sh</span> <span class="s2">&quot;cc -c -o </span><span class="si">#{</span><span class="n">obj</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">fn</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Just a couple things to note about the above code.</p>

<p>关于上面的代码仅有两个需要注意的地方。</p>

<ul>
<li><p>The dependencies are not specified. This is a common where we specify the dependents at one place and the actions in another. Rake is smart enough to combine the dependencies with the actions.</p></li>
<li><p>依赖没有指定。这种在一个地方定义指定依赖另一个地方执行是一种普遍现象，Rake具有足够的智能去绑定这些依赖关系和行为。</p></li>
<li><p>Although the task was named after the .o (which is, after all, what we want to generate), the file list is defined in terms of the .c files. Why?</p></li>
<li><p>尽管任务使用 .o 来命名 (毕竟这些是我们想去生成的东西), 但是文件列表依照 .c 去定义，为什么呢？</p></li>
</ul>


<p>The simple reason is that file lists search for file names that exist in the file system. We have no guarantee that the .o files even exist at this point (indeed, the will not after invoking the clean task). The .c are source and will always be there.</p>

<p>一个简单的理由是文件列表在文件系统中搜索已经存在的文件的文件名。我们不能保证.o文件是一直存在的.(确实，在调用clean任务后就会没有了). .c作为源代码总是存在。</p>

<p>Rake Can Automatically Generate Tasks</p>

<p>Rake 能自动生成任务</p>

<p>Defining tasks in a loop is pretty cool, but is really not needed in a number of simple cases. Rake can automatically generate file based tasks according to some simple pattern matching rules.</p>

<p>在一个循环中定义任务很酷，但是在一些简单的任务中并不需要。Rake能基于基本的任务规则去生成相应匹配的任务。</p>

<p>For example, we can capture the above logic in a single rule … no need to find all the source files and iterate through them.</p>

<p>示例，我们可以按照一个单个的规则来捕获上面的逻辑。 不需要查找所有的源代码并迭代处理。</p>

<p>Rakefile Fragment</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">rule</span> <span class="s1">&#39;.o&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;.c&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
</span><span class='line'>  <span class="n">sh</span> <span class="s2">&quot;cc -c -o </span><span class="si">#{</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">t</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The above rule says that if you want to generate a file ending in .o, then you if you have a file with the same base name, but ending in .c, then you can generate the .o from the .c.</p>

<p>上面的规则说如果你要生成一个以 .o 结尾的文件，然后如果你有一个文件和基础文件有相同的名称，但是你可以从 .c 文件生成 .o</p>

<p>t.name is the name of the task, and in file based tasks will be the name of the file we are trying to generate. t.source is the name of the source file, i.e. the one that matches the second have of the rule pattern. t.source is only valid in the body of a rule.</p>

<p>t.name 是任务的名称，在文件任务中，我们会尝试以文件的名称来命名生成的文件。 t.source 是其源文件的名字，i.e. the one that matches the second have of the rule pattern. t.source 在规则中唯一有效的。</p>

<p>Rules are actually much more flexible than you are led to believe here. But that’s an advanced topic that we will save for another day.</p>

<p>规则实际上可以做的比你想象中的更加灵活。但是那是高级话题，我们会在以后再说。</p>

<p>Final Rakefile</p>

<p>Here is our final resule. Notice how we use the SRC and OBJ file lists to manage our lists of scource files and object files.</p>

<p>这是我们最终的结果。提示我们是怎么使用SRC和OBJ文件列表去管理我们的源文件和目标文件的。</p>

<p>Rakefile</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="s1">&#39;rake/clean&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="no">CLEAN</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="s1">&#39;*.o&#39;</span><span class="p">)</span>
</span><span class='line'><span class="no">CLOBBER</span><span class="o">.</span><span class="n">include</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">task</span> <span class="ss">:default</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;hello&quot;</span><span class="o">]</span>
</span><span class='line'>
</span><span class='line'><span class="no">SRC</span> <span class="o">=</span> <span class="no">FileList</span><span class="o">[</span><span class="s1">&#39;*.c&#39;</span><span class="o">]</span>
</span><span class='line'><span class="no">OBJ</span> <span class="o">=</span> <span class="no">SRC</span><span class="o">.</span><span class="n">ext</span><span class="p">(</span><span class="s1">&#39;o&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">rule</span> <span class="s1">&#39;.o&#39;</span> <span class="o">=&gt;</span> <span class="s1">&#39;.c&#39;</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
</span><span class='line'>  <span class="n">sh</span> <span class="s2">&quot;cc -c -o </span><span class="si">#{</span><span class="n">t</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">t</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">file</span> <span class="s2">&quot;hello&quot;</span> <span class="o">=&gt;</span> <span class="no">OBJ</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">sh</span> <span class="s2">&quot;cc -o hello </span><span class="si">#{</span><span class="no">OBJ</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># File dependencies go here ...</span>
</span><span class='line'><span class="n">file</span> <span class="s1">&#39;main.o&#39;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s1">&#39;main.c&#39;</span><span class="p">,</span> <span class="s1">&#39;greet.h&#39;</span><span class="o">]</span>
</span><span class='line'><span class="n">file</span> <span class="s1">&#39;greet.o&#39;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s1">&#39;greet.c&#39;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/translator/blog/2012/12/21/rake-tutorial/">Rake Tutorial</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-21T20:54:00+08:00" pubdate data-updated="true">Dec 21<span>st</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://docs.rubyrake.org/tutorial/index.html">Rake Tutorial</a></p>

<h2>Rake 指南</h2>

<p>Rake is a build tool, written in Ruby, using Ruby as a build language. Rake is similar to make in scope and purpose. Rake a simple ruby build program with capabilities similar to make.</p>

<p>Rake 是用Ruby写的Build工具，使用Ruby作为Build语言。Rake的目标和适用范围和make类似。Rake是一个简单的Ruby程序和make具有相似的功能。</p>

<p>Rake has the following features:</p>

<p>Rake 具有以下特征</p>

<ul>
<li><p>Rakefiles (rake’s version of Makefiles) are completely defined in standard Ruby syntax. No XML files to edit. No quirky Makefile syntax to worry about (is that a tab or a space?)</p>

<p>  Rakefiles (Rake版本的Makefiles) 完全使用的标准的Ruby语法定义。不用编辑xml文件。没有Makefile的诡异语法问题比如(Tab和空格)</p></li>
<li><p>Users can specify tasks with prerequisites.</p>

<p>  用户可以指定执行某个预设的任务</p></li>
<li><p>Rake supports rule patterns to sythesize implicit tasks.</p>

<p>  Rake 支持规则模式查找任务</p></li>
<li><p>Rake is lightweight. It can be distributed with other projects as a single file. Projects that depend upon rake do not require that rake be installed on target systems.</p>

<p>  Rake 是轻量级的。它可以作为单个文件分发给其他项目。那些依赖于rake的项目并不强制要求rake安装在目标系统上。</p></li>
</ul>


<p><strong>Copyright</strong></p>

<p>Copyright © 2005, by Jim Weirich, Some rights reserved.</p>

<h3>Chapter 1—Introducing Rake</h3>

<p>章节 1 介绍Rake</p>

<h4>Getting Started</h4>

<p>起始</p>

<p><strong>Received via EMail:</strong></p>

<p>收到一些EMail</p>

<blockquote><blockquote><p>I have just started using the excellent Rake tool (thanks, Jim!) and I am at a bit of a loss on how to proceed. I am attempting to   create unit test for some C++ code I am creating, [&#8230;]</p>

<p>我已经开始使用这个Rake工具(感谢Jim), 我花费很多时间去用它。我试图为我的一些C++代码创建unite test&#8230;</p></blockquote></blockquote>

<p>Several people recently have made similar comments, they really like rake, but have had trouble getting started. Although the Rake documentation is fairly complete, it really does assume you are familiar with other build tools such as ant and make. It is not really material for the newbie.</p>

<p>最近有很多人都提到类似的意见，他们真的很喜欢rake，但是他们不知道怎么上手。尽管Rake的文档已经很全面了，但它真的是基于你已经接触过Build家族的其他工具，比如ant和make。所以它也确实不太适合新手。</p>

<p>This tutorial is an attempt to address this lack. We will start with a very simple problem: Building a Simple C Program.</p>

<p>此指南正是弥补这个不足。我们会从一个简单的问题开始：Building 一个简单的C程序</p>

<p><strong>The Problem</strong></p>

<p>We will start with a very simple build problem, the type of problem that make (and now rake) was desiged to deal with.</p>

<p>我们从一个非常简单的build问题入手，这类问题正是make(现在是rake)设计的目的。</p>

<p>Suppose I have a very simple C program consisting of the following files.</p>

<p>比如我有一个非常简单的C程序，有以下一些文件</p>

<figure class='code'><figcaption><span>main.c  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;greet.h&quot;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">greet</span> <span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>greet.h  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">extern</span> <span class="kt">void</span> <span class="n">greet</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">who</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span>greet.c  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">greet</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">who</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Hello, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">who</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>(Yes, it really is the old standard “Hello, World” program. I did say we were starting with the basics!)</p>

<p>(是的，这是一个旧式的的“Hello, World”程序。正如我说过的我们从基础开始。)</p>

<p>To compile and run this collection of files, a simple shell script like the following is adequate.</p>

<p>编译并运行这些文件， 使用下面的一个简单的shell脚本</p>

<figure class='code'><figcaption><span>build.sh  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#include &lt;stdio.h&gt;</span>
</span><span class='line'>void greet <span class="o">(</span>const char * who<span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="nb">printf</span> <span class="o">(</span><span class="s2">&quot;Hello, %s\n&quot;</span>, who<span class="o">)</span>;
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>For those not familiar with compiling C code, the cc command is the C compiler. It generates an output file (specified by the -o flag) from the source files listed on the command line.</p>

<p>如果大家不熟悉编译C代码， 命令cc是一个C编译器。在命令行里读取指定的源代码之后生成一个输出文件(使用参数-o)</p>

<p>Running it gives us the following results …</p>

<p>运行它之后我们会得到下面这些结果</p>

<figure class='code'><figcaption><span>output </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ build.sh
</span><span class='line'>$ ./hello
</span><span class='line'>Hello, World</span></code></pre></td></tr></table></div></figure>


<p><strong>Building C Programs</strong></p>

<p>Compiling C programs is really a two step process. First you compile all the source code file into object files. Then you take all the object files and link them together to make the executable.</p>

<p>编译C程序实际上有两步过程。首先你编译所有的源代码文件到对象文章中。然后你再link这些对象文件去创建一个可执行文件。</p>

<p>The following figure illustrates the progression from source files to object files to executable program.</p>

<p>接下来的流程是从源码到对象文件再到可执行程序。</p>

<p>Our program is so small that there is little benefit in doing more than the three line build script above. However, as projects grow, there are more and more source files and object files to manage. Recompiling everything for a simple one line change in a single source file gets old quickly. It is much more efficient to just recompile the few files that change and then relink.</p>

<p>我们的程序小到以至于只用了三行build脚本就可以搞定。然而，随着项目的增长，这里会有更多的源代码文件和对象文件需要管理。在源码中任意一行代码的更改都需要重新编译所有的东西。它必须只去编译那些更改的文件并重新链接才会更有效。</p>

<p>But how do we know what to recompile? Keeping track of that would be quite error prone if we tried to do that by hand. Here is where Rake become useful.</p>

<p>但是我们怎么指导哪些需要重新编译？ 如果我们尝试手动的去跟踪常常会遇到一些错误。这时候Rake就派上用场了。</p>

<p><strong>File Dependencies</strong></p>

<p>文件依赖</p>

<p>First, lets take a look at when files need to be recompiled. Consider the main.o. Obviously if the main.c file changes, then we need to rebuild main.o. But are the other files that can trigger a recompile of main.o?</p>

<p>首先，让我们看看哪些文件需要重新编译的。看一下 main.o，显然的，如果 main.c 文件更改了，那么我们需要重新build main.o。 但是其他的文件也会触发重新编译main.o？</p>

<p>Actually, yes. Looking at the source of main.c, we see that it includes the header file greet.h. That means any changes in greet.h could possibly effect the main.o file as well.</p>

<p>事实上是的。看main.c的源代码，我们看到它包含了一个头文件greet.h。那意味着greet.h的改变也会影响main.o。</p>

<p>We say that main.o has a dependency on the files main.c and greet.h. We can capture this dependency in Rake with the following line:</p>

<p>由此我们可以知道main.o依赖main.c和greet.h。使用Rake我们可以使用一行代码去处理这个依赖问题。</p>

<p><strong>Rakefile Fragment</strong></p>

<p>Rakefile 片段</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">file</span> <span class="s2">&quot;main.o&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.c&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.h&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>The rake dependency declaration is just regular Ruby code. We take advantage of the fact that we can construct hash arguments on the fly, and that Ruby doesn’t require parenthesis around the method arguement to create a file task declaration that reads very naturally to the humans reading the rake file. But its still just Ruby code.</p>

<p>rake依赖定义是一个正常的Ruby代码。实际上我们利用了Ruby的hash结构的参数，并且不需要括号来包裹参数，创建文件任务定义读起来是那么的自然，人性化。 但它的确只是Ruby代码。</p>

<p>Likewise, we can declare the dependencies for creating the “greet.o” file as well.</p>

<p>同样的，我们定义一个创建“greet.o”的依赖关系。</p>

<p><strong>Rakefile Fragment</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">file</span> <span class="s2">&quot;greet.o&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;greet.c&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>greet.c does include stdio.h, but since that is a system header file and not subject to change (often), we can leave itout of the dependency list.</p>

<p>greet.c包含stdio.h，但是系统头文件常常不会变动，我们可以不用再写它的依赖列表。</p>

<p>Finally we can declare the dependencies for the executable program hello. It just depends on the two object files.</p>

<p>最终，我们可以定义可执行文件hello的依赖关系。它只依赖两个对象文件。</p>

<p><strong>Rakefile Fragment</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">file</span> <span class="s2">&quot;hello&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.o&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.o&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice that we only have to declare the direct dependencies of hello. Yes, hello depends on main.o which in turn depends on main.c. But the .c files are not directly used in building hello, so they can safely be omitted from the list.</p>

<p>提醒一下，我们只是定义了hello的直接依赖。hello依赖main.o它又依赖main.c。但是.c源码文件没有直接用来build hello，所以它可以安全的被忽略。</p>

<p><strong>Building the Files</strong></p>

<p>We have carefully specified how the files are related. Now we need to say what Rake would have to do to build the files when needed.</p>

<p>我们仔细的指出这些文件是如何关联的。现在我们需要告诉你当build这些文件的时候rake是怎么工作的。</p>

<p>This part is pretty simple. The three line build script that we started with contains all the commands needed to build the program. We just need to put those actions with the right set of dependencies. Use a Ruby do / end block to capture actions …</p>

<p>这部分相当的简单。这三行build脚本包含了build程序所有的命令。我们只要把它们放在正确的依赖关系上。使用Ruby的 do/end 块去包裹这些指令。</p>

<p>The result looks like this:</p>

<p>结果看上去如下</p>

<p><strong>Rakefile</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'> <span class="n">file</span> <span class="s1">&#39;main.o&#39;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.c&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.h&quot;</span><span class="o">]</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">sh</span> <span class="s2">&quot;cc -c -o main.o main.c&quot;</span>
</span><span class='line'> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'> <span class="n">file</span> <span class="s1">&#39;greet.o&#39;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s1">&#39;greet.c&#39;</span><span class="o">]</span> <span class="k">do</span>
</span><span class='line'>   <span class="n">sh</span> <span class="s2">&quot;cc -c -o greet.o greet.c&quot;</span>
</span><span class='line'> <span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">file</span> <span class="s2">&quot;hello&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.o&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.o&quot;</span><span class="o">]</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">sh</span> <span class="s2">&quot;cc -o hello main.o greet.o&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>Trying it out</strong></p>

<p>So, let’s see if it works!</p>

<p>然我们看看它是怎么工作的吧。</p>

<p><strong>Output</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rake hello
</span><span class='line'>  <span class="o">(</span>in /home/jim/pgm/rake/intro<span class="o">)</span>
</span><span class='line'>  cc -c -o main.o main.c
</span><span class='line'>  cc -c -o greet.o greet.c
</span><span class='line'>  cc -o hello main.o greet.o
</span></code></pre></td></tr></table></div></figure>


<p>The command line rake hello instructs rake to look through its list of tasks and find one called “hello”. It then checks hello’s dependencies and builds them if required. Finally, when everything is ready it builds hello by executing the C compiler command.</p>

<p>命令rake hello告诉rake去到任务列表中找到一个叫“hello”的任务。然后它检查build hello的依赖关系。最终，准备妥当后执行C编译命令。</p>

<p>Rake dutifully reports what it is doing as it goes along. We can see that each compiler invocation is done in the correct order, building the main program at the end. So, does the program work? Let’s find out.</p>

<p>Rake诚实的报告了它独自做了什么事情。我们看到build main程序从都到尾调用的顺序。</p>

<p><strong>Output</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./hello
</span><span class='line'>Hello, World
</span></code></pre></td></tr></table></div></figure>


<p>Success!</p>

<p>搞定</p>

<p>But what happens when we change a file. Lets change the greet function in greet.c to print “Hi” instead of hello.</p>

<p>但是我们更改了一个文件后会发生什么事情呢？ 我们来修改greet.c文件中的greet方法，用打印“Hi”去替换hello。</p>

<p><strong>Output</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>emacs greet.c
</span><span class='line'><span class="nv">$ </span>rake hello
</span><span class='line'><span class="o">(</span>in /home/jim/pgm/rake/intro<span class="o">)</span>
</span><span class='line'>cc -c -o greet.o greet.c
</span><span class='line'>cc -o hello main.o greet.o
</span><span class='line'><span class="err">$</span>
</span><span class='line'><span class="nv">$ </span>./hello
</span><span class='line'>Hi, World
</span></code></pre></td></tr></table></div></figure>


<p>Notice that it recompiles greet.c making a new greet.o. And then it needs to relink hello with the new greet.o. Then it is done. There is no need to recompile main.c since it never changed.</p>

<p>提示，它重新编译了greet.c去创建新的greet.o。之后，它需要用新的greet.o去重新link hello。这样就完成了。由于main.c没有任何的改变，在这里不需要重新编译。</p>

<p>What do you think will happend if we run Rake again?</p>

<p>你认为重新执行Rake会发生什么事情？</p>

<p><strong>Output</strong></p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rake hello
</span><span class='line'><span class="o">(</span>in /home/jim/pgm/rake/intro<span class="o">)</span>
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure>


<p>That’s right … nothing. Everything is up to date with its dependencies, so there is no work for Rake to do.</p>

<p>哈哈，什么也没发生。所有的都是最新的，所以Rake不需要做任何事情。</p>

<p>Ok, sure. Rake is a bit of overkill for only two source files and a header. But imagine a large project with hundreds of files and dependencies. All of a sudden, a tool like Rake becomes very attractive.</p>

<p>的确，Rake对只有两个源码和一个头文件的项目十分在行。但是，想象一个大项目，有上百个文件和依赖关系，像Rake这样的工具也会非常地受欢迎。</p>

<h4>Summary</h4>

<p>What have we learned? Building a Rakefile involves identifying dependencies and the actions required to create the target files. Then declaring the dependencies and actions are as simple as writing them down in standard Ruby code. Rake then handles the details of building</p>

<p>我们学到了什么呢？创建一个Rakefile，这涉及到识别目标文件的依赖关系和动作, 然后将这些用标准的Ruby代码写到Rakefile中。最后交给Rake去处理building的细节。</p>

<h4>What’s Up Next</h4>

<p>接下来</p>

<p>We notice that even our small example has a bit of duplication in it. We have specify how to compile both C file separately, even though the only difference is the files that are used. The next installment will look at fixing that problem as well as introduce non-file based tasks, rules and file lists.</p>

<p>我们依然会用一个小的示例。我们会指定如何独立地编译C文件，即使是使用上的区别。下面问会解决一些文件无关的任务规则。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/translator/blog/2012/12/15/how-emacs-changed-my-life/">How Emacs Changed My Life</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-15T19:37:00+08:00" pubdate data-updated="true">Dec 15<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这篇文章是Ruby之父松本行弘(Matz)先生的演讲稿，介绍了Emacs是如何走进并改变他的生活以及为他开发Ruby提供的各种帮助。</p>

<p><a href="http://www.slideshare.net/yukihiro_matz/how-emacs-changed-my-life">原文链接</a> <em>Fuck GFW first</em></p>

<blockquote><blockquote><p>How Emacs changed my life</p>

<p>Yukihiro &#8220;Matz&#8221; Matsumoto
@yukihiro_matz</p></blockquote></blockquote>

<p>Emacs 如何改变了我的生活</p>

<blockquote><blockquote><p>1980</p>

<p>I started programming</p></blockquote></blockquote>

<p>我开始了编程</p>

<p><img src="https://raw.github.com/tairan/translator/master/source/assets/images/2012-12-15/sharp.png" alt="sharp" /></p>

<blockquote><blockquote><p>BASIC</p>

<p>400 steps</p></blockquote></blockquote>

<p>在那个上面用BASIC写了400多条操作</p>

<blockquote><blockquote><p>1988</p>

<p>I met Emacs</p>

<p>On Sun-3</p></blockquote></blockquote>

<p>1988年，在Sun-3上面，我接触了 Emacs</p>

<blockquote><blockquote><p>Shared by 200 undergraduates</p></blockquote></blockquote>

<p>那个机器由200个本科生共享</p>

<blockquote><blockquote><p>I tried Emacs</p>

<p>But I never used</p></blockquote></blockquote>

<p>我尝试了一下Emacs但是并没有使用它</p>

<blockquote><blockquote><p>Emacs was prohibited</p></blockquote></blockquote>

<p>Emacs 是被限制的</p>

<blockquote><blockquote><p>It consumed too much precious memory</p></blockquote></blockquote>

<p>它需要太多的宝贵的内存</p>

<blockquote><blockquote><p>We are free to download free software</p>

<p>We are free to read the source code</p></blockquote></blockquote>

<p>我们可以自由的下载免费自由的软件也可以自由的阅读源代码</p>

<blockquote><blockquote><p>I downloaded Emacs source code</p>

<p>and investigated</p></blockquote></blockquote>

<p>我下载了Emacs源码并研究它</p>

<blockquote><blockquote><p>Emacs was my first Lisp interpreter</p></blockquote></blockquote>

<p>Emacs 是我第一个Lisp直译器</p>

<blockquote><blockquote><p>I learned a lot about language implementation from Emacs</p></blockquote></blockquote>

<p>我从Emacs那里学到了很多关于语言实现的东西</p>

<blockquote><blockquote><p>Embadding integers in pointers</p></blockquote></blockquote>

<p>在指针里嵌入整数</p>

<blockquote><blockquote><p>Mark and sweep garbage collection</p></blockquote></blockquote>

<p>标记和清扫垃圾收集</p>

<blockquote><blockquote><p>Calling convention between Lisp and C</p></blockquote></blockquote>

<p>在Lisp和C之间相互转换调用</p>

<blockquote><blockquote><p>I really understood how Lisp work</p></blockquote></blockquote>

<p>我确实地了解了Lisp是如何工作的</p>

<blockquote><blockquote><p>I was fascinated by Lisp objects</p></blockquote></blockquote>

<p>我沉迷于Lisp的对象</p>

<blockquote><blockquote><p>Lisp objects implemented by C</p></blockquote></blockquote>

<p>Lisp 对象是由C实现的</p>

<blockquote><blockquote><p>Then I got a Sparc Station</p></blockquote></blockquote>

<p>之后我得到一台Sparc工作站</p>

<blockquote><blockquote><p>I started to use Emacs</p></blockquote></blockquote>

<p>我开始使用Emacs了</p>

<blockquote><blockquote><p>Emacs become part of me</p></blockquote></blockquote>

<p>Emacs 成为了我的一部分</p>

<blockquote><blockquote><p>If I didn&#8217;t like anything in Emacs, I could change it</p></blockquote></blockquote>

<p>如果我不喜欢Emacs的哪个部分，我可以修改它</p>

<blockquote><blockquote><p>Emacs is totally configurable</p></blockquote></blockquote>

<p>Emacs是完全可配置的</p>

<blockquote><blockquote><p>Emacs made me realize anything can be changed by a programmer</p></blockquote></blockquote>

<p>Emacs让我意识到作为一名程序员可以改变一切</p>

<blockquote><blockquote><p>It is total freedom</p></blockquote></blockquote>

<p>它完全是自由的</p>

<blockquote><blockquote><p>I could edit without thinking key bindding</p></blockquote></blockquote>

<p>我可以在编辑的时候不用考虑各种组合键绑定</p>

<blockquote><blockquote><p>I didn&#8217;t want to write anything without Emacs</p></blockquote></blockquote>

<p>离开了Emacs我什么都不想写</p>

<blockquote><blockquote><p>Programs, Documents and Mails</p></blockquote></blockquote>

<p>程序，文档以及邮件等</p>

<blockquote><blockquote><p>so I wrote my own mail client</p></blockquote></blockquote>

<p>于是我写了自己的邮件客户端</p>

<blockquote><blockquote><p>named &#8220;cmail&#8221;</p></blockquote></blockquote>

<p>我给他命名叫 &#8220;cmail&#8221;</p>

<blockquote><blockquote><p>in Emacs lisp</p>

<p>It was my first non-trivial (Emacs) Lisp program</p></blockquote></blockquote>

<p>在 Emacs lisp 中，它是我第一个Lisp程序，意味深长。</p>

<blockquote><blockquote><p>I used it everyday</p></blockquote></blockquote>

<p>我每天都在使用它</p>

<blockquote><blockquote><p>1993</p>

<p>I started Ruby development</p></blockquote></blockquote>

<p>1993， 我开始开发Ruby</p>

<blockquote><blockquote><p>with influence from Emacs implementation</p>

<p>Integers are coded in tagged pointers</p>

<p>It uses simple marked sweep garbage collection</p>

<p>It uses similar object model to Lisp</p></blockquote></blockquote>

<p>受Emacs实现的影响，Intergers are coded in tagged pointers (<strong>Could someone help me to translate it?</strong>)</p>

<p>它使用了简单的标记和清扫垃圾收集</p>

<p>它使用了和lisp相似的对象模型</p>

<blockquote><blockquote><p>Then I put Smalltalk-like OO system on top</p></blockquote></blockquote>

<p>之后我在它上层封装了类似 smalltalk 的面向对象系统</p>

<blockquote><blockquote><p>For syntax, I wanted Algol/Ada/Eiffel like one</p></blockquote></blockquote>

<p>语法方面，从Algol/Ada/Eiffel 吸收了一点</p>

<blockquote><blockquote><p>But as an Emacs addict, I needed a language model
作为一个对Emacs重度依赖的人来说，我需要一个language-model</p>

<p>auto-indent was a must</p></blockquote></blockquote>

<p>自动缩进是必须的</p>

<blockquote><blockquote><p>Back to 1993, there was no auto-indenting language mode for a language with such syntax</p></blockquote></blockquote>

<p>回到1993， 还没有一个可以自动缩进的 language-mode 为这样的语法</p>

<blockquote><blockquote><p>So I tried to write experimental ruby-model.el</p></blockquote></blockquote>

<p>所以，我试着写一个 ruby-model.el</p>

<blockquote><blockquote><p>fighting with emacs lisp and regular expression,</p>

<p>for almost whole week</p></blockquote></blockquote>

<p>差不多和emacs lisp以及正则表达式奋战了整整一周</p>

<blockquote><blockquote><p>I somehow succeeded to implement auto-indentation</p>

<p>for a languge with &#8220;end&#8221; delimiters</p></blockquote></blockquote>

<p>我成功的实现了一个可以基于 &#8216;end&#8217; 结尾的自动缩进功能</p>

<blockquote><blockquote><p>If I couldn&#8217;t make ruby-model to work</p></blockquote></blockquote>

<p>如果我不能让 ruby-model 工作起来</p>

<blockquote><blockquote><p>The syntax of Ruby would have changed</p>

<p>to more C-like one</p>

<p>too similar to other scripting languages</p></blockquote></blockquote>

<p>Ruby 的语法也许就要改变的像C一样或者类似其他的脚本语言</p>

<blockquote><blockquote><p>as a result, Ruby would not have gained current popularity</p></blockquote></blockquote>

<p>那样的话，Ruby 也许就不会像现在这样流行了</p>

<blockquote><blockquote><p>Summary</p>

<ol>
<li>Emacs taught me freedom for software</li>
<li>Emacs taught me how to read source code</li>
<li>Emacs taught me power of Lisp</li>
<li>Emacs taught me how to implement a language core</li>
<li>Emacs taught me how to implement a garbage collector</li>
<li>Emacs helped me to code and debug</li>
<li>Emacs helped me to write and edit text/mails/doucments</li>
<li>Emacs helped me to be a effective programmer</li>
<li>Emacs made me a hacker</li>
<li>Emacs has changed my life
forever</li>
</ol>
</blockquote></blockquote>

<p>总结</p>

<ol>
<li>Emacs 告诉我软件的自由</li>
<li>Emasc 告诉我如何阅读源代码</li>
<li>Emacs 告诉我Lisp的强大之处</li>
<li>Emacs 告诉我如何实现一个语言的核心</li>
<li>Emacs 告诉我如何实现一个垃圾收集器</li>
<li>Emacs 帮助我去写代码和调试代码</li>
<li>Emacs 帮助我撰写编辑各种文字，邮件和文档</li>
<li>Emacs 帮助我成为一名高效的程序员</li>
<li>Emasc 塑造我成为一名黑客</li>
<li>Emacs 永远的改变了我的生活</li>
</ol>


<blockquote><blockquote><p>Thank you</p></blockquote></blockquote>

<p>谢谢</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/translator/blog/2012/12/08/devdiv-tfs-database-sizes/">DevDiv TFS Database Sizes</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-08T13:53:00+08:00" pubdate data-updated="true">Dec 8<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这是一篇来自Brian Harry的博客，介绍文章发表时(2009)TFS团队自己的TFS数据库的状况。</p>

<p><a href="http://blogs.msdn.com/b/bharry/archive/2009/05/31/devdiv-tfs-database-sizes.aspx">原文链接</a></p>

<blockquote><p>Someone asked me the other day how big to expect the relative sizes of TFS databases to be.  At the time all I had time to say was “Over time TfsVersionControl will dwarf everything else”.  This weekend, I finally had a few minutes to sit down and do some analysis.  As with all such things, your mileage will vary.  DevDiv is a VERY heavy version control user and this may be a bit disproportionate from what you’ll see but as a system grows, I expect it will start to look more and more like this.</p></blockquote>

<p>有人问我TFS数据库会多大？ 一般我都是回答“随着时间的推移，TfsVersionControl总会显得很壮观&#8221;。 这周末，我终于有点时间坐下来就此做一些分析。每个人的情况会有一些区别。DevDiv是TFS一个很大的用户，并且可能与你看到过的系统增长有些不同。我期望能看到更多彼此的相似之处。</p>

<blockquote><p>Here’s a pie chart that shows you relative sizes:</p></blockquote>

<p>这是一幅数据库大小相关的饼图</p>

<p><img src="http://blogs.msdn.com/blogfiles/bharry/WindowsLiveWriter/DevDivTFSDatabaseSizes_BB10/image_thumb_5.png" alt="a pie chart shows you relatvie sizes" /></p>

<blockquote><p>And here’s the actual numbers:</p></blockquote>

<p>以及一些真实的数据</p>

<p><img src="http://blogs.msdn.com/blogfiles/bharry/WindowsLiveWriter/DevDivTFSDatabaseSizes_BB10/image_thumb_6.png" alt="the actual numbers" /></p>

<blockquote><p>It’s worth looking at how TfsVersionControl breaks down.  Note this won’t match your schema exactly because it is a hybrid TFS 2008/TFS 2010 schema but what I show you will be close.</p></blockquote>

<p>TfsVersionControl很值得去分析一下。 提醒这个和你实际的数据库schema不一致，因为他是一个TFS 2008/TFS 2010的schema混合体，但是他很接近我想要说的意思。</p>

<p><img src="http://blogs.msdn.com/blogfiles/bharry/WindowsLiveWriter/DevDivTFSDatabaseSizes_BB10/image_thumb_3.png" alt="TfsVersionControl Database"></p>

<p><img src="http://blogs.msdn.com/blogfiles/bharry/WindowsLiveWriter/DevDivTFSDatabaseSizes_BB10/image_thumb_4.png" alt="the table's numbers" /></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/translator/blog/2012/12/07/hello-world/">Hello World</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-07T13:57:00+08:00" pubdate data-updated="true">Dec 7<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h1>Translator</h1>

<p><strong>Practice, Practice, Practice</strong></p>

<p>For learning English, I try to translate some articles which are my interesting realm, mostly are related to technology, startup, business etc.</p>

<p>if you also like to translate somethings please join me, welcome :)</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
    <a href="/translator/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/translator/blog/2013/01/04/rake-tutorial-2/">Rake Tutorial 2</a>
      </li>
    
      <li class="post">
        <a href="/translator/blog/2012/12/21/rake-tutorial/">Rake Tutorial</a>
      </li>
    
      <li class="post">
        <a href="/translator/blog/2012/12/15/how-emacs-changed-my-life/">How Emacs changed my life</a>
      </li>
    
      <li class="post">
        <a href="/translator/blog/2012/12/08/devdiv-tfs-database-sizes/">DevDiv TFS Database Sizes</a>
      </li>
    
      <li class="post">
        <a href="/translator/blog/2012/12/07/hello-world/">Hello World</a>
      </li>
    
  </ul>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Tairan Wang -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'tairan';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
