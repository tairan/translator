<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rake | Translate somethings]]></title>
  <link href="http://tairan.github.com/translator/blog/categories/rake/atom.xml" rel="self"/>
  <link href="http://tairan.github.com/translator/"/>
  <updated>2012-12-22T21:51:39+08:00</updated>
  <id>http://tairan.github.com/translator/</id>
  <author>
    <name><![CDATA[Tairan Wang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rake Tutorial]]></title>
    <link href="http://tairan.github.com/translator/blog/2012/12/21/rake-tutorial/"/>
    <updated>2012-12-21T20:54:00+08:00</updated>
    <id>http://tairan.github.com/translator/blog/2012/12/21/rake-tutorial</id>
    <content type="html"><![CDATA[<p><a href="http://docs.rubyrake.org/tutorial/index.html">Rake Tutorial</a></p>

<h2>Rake 指南</h2>

<p>Rake is a build tool, written in Ruby, using Ruby as a build language. Rake is similar to make in scope and purpose. Rake a simple ruby build program with capabilities similar to make.</p>

<p>Rake 是用Ruby写的Build工具，使用Ruby作为Build语言。Rake的目标和适用范围和make类似。Rake是一个具有和make类似功能的简单Ruby程序。</p>

<p>Rake has the following features:</p>

<p>Rake 具有一下特征</p>

<ul>
<li><p>Rakefiles (rake’s version of Makefiles) are completely defined in standard Ruby syntax. No XML files to edit. No quirky Makefile syntax to worry about (is that a tab or a space?)</p>

<p>  Rakefiles (Rake版本的Makefiles) 使用完全的标准Ruby语法定义。不用编辑xml文件。没有Makefile的诡异语法问题比如(Tab和空格)</p></li>
<li><p>Users can specify tasks with prerequisites.</p>

<p>  用户可以指定执行预设的任务</p></li>
<li><p>Rake supports rule patterns to sythesize implicit tasks.</p>

<p>  Rake 支持规则模式查找任务</p></li>
<li><p>Rake is lightweight. It can be distributed with other projects as a single file. Projects that depend upon rake do not require that rake be installed on target systems.</p>

<p>  Rake 是轻量级的。它可以在单个文件中分布式处理不同的项目。项目依赖在rake上，不强制要求rake安装在目标系统上。</p></li>
</ul>


<p><strong>Copyright</strong></p>

<p>Copyright © 2005, by Jim Weirich, Some rights reserved.</p>

<h3>Chapter 1—Introducing Rake</h3>

<p>章节 1 介绍Rake</p>

<h4>Getting Started</h4>

<p>起始</p>

<p><strong>Received via EMail:</strong></p>

<p>收到一些EMail</p>

<blockquote><blockquote><p>I have just started using the excellent Rake tool (thanks, Jim!) and I am at a bit of a loss on how to proceed. I am attempting to   create unit test for some C++ code I am creating, [...]</p>

<p>我正好开始使用Rake工具(感谢Jim), 我花费很多时间去处理。我去创建我为C++代码创建unite test，创建...</p></blockquote></blockquote>

<p>Several people recently have made similar comments, they really like rake, but have had trouble getting started. Although the Rake documentation is fairly complete, it really does assume you are familiar with other build tools such as ant and make. It is not really material for the newbie.</p>

<p>很多人都有类似的意见，他们这的很喜欢rake，但是他们不知道怎么上手。通过完整的Rake文档，它真的和你接触到的Build工具是同一家族的，比如ant和make。它也确实不太适合新手。</p>

<p>This tutorial is an attempt to adderess this lack. We will start with a very simple problem: Building a Simple C Program.</p>

<p>此指南正是弥补这个不足。我们会从一个简单的问题开始：Building 一个简单的C程序</p>

<p><strong>The Problem</strong></p>

<p>We will start with a very simple build problem, the type of problem that make (and now rake) was desiged to deal with.</p>

<p>我们从一个非常简单的build问题入手，这类问题正是make(现在是rake)设计的目的。</p>

<p>Suppose I have a very simple C program consisting of the following files.</p>

<p>比如我有一个非常简单的C程序，有以下一些文件</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>main.c  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="s">&quot;greet.h&quot;</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">greet</span> <span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">);</span>
</span><span class='line'><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>greet.h  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">extern</span> <span class="kt">void</span> <span class="n">greet</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">who</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>greet.c  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">include</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">stdio</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="kt">void</span> <span class="n">greet</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">who</span><span class="p">)</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Hello, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">who</span><span class="p">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>(Yes, it really is the old standard “Hello, World” program. I did say we were starting with the basics!)</p>

<p>(是的，这是一个旧式的的“Hello, World”程序。正如我说过的我们从基础开始。)</p>

<p>To compile and run this collection of files, a simple shell script like the following is adequate.</p>

<p>编译并运行这些文件， 使用下面的一个简单的shell脚本</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>build.sh  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;h1&gt;include &amp;lt;stdio.h&gt;&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;void greet <span class="o">(</span>const char * who<span class="o">)</span> <span class="o">{</span>&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;pre&gt;&lt;code&gt;printf <span class="o">(</span><span class="s2">&quot;Hello, %s\n&quot;</span>, who<span class="o">)</span>;
</span><span class='line'>&lt;/code&gt;&lt;/pre&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;<span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>For those not familiar with compiling C code, the cc command is the C compiler. It generates an output file (specified by the -o flag) from the source files listed on the command line.</p>

<p>如果大家不熟悉编译C代码， 命令cc是一个C编译器。在命令行里读取指定的源代码之后生成一个输出文件(使用参数-o)</p>

<p>Running it gives us the following results …</p>

<p>运行它之后我们会得到下面这些结果</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>output </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$ build.sh
</span><span class='line'>$ ./hello
</span><span class='line'>Hello, World</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><strong>Building C Programs</strong></p>

<p>Compiling C programs is really a two step process. First you compile all the source code file into object files. Then you take all the object files and link them together to make the executable.</p>

<p>编译C程序实际上有两步过程。首先你编译所有的源代码文件到对象文章中。然后你再link这些对象文件去创建一个可执行文件。</p>

<p>The following figure illustrates the progression from source files to object files to executable program.</p>

<p>接下来的流程是从源码到对象文件再到可执行程序。</p>

<p>Our program is so small that there is little benefit in doing more than the three line build script above. However, as projects grow, there are more and more source files and object files to manage. Recompiling everything for a simple one line change in a single source file gets old quickly. It is much more efficient to just recompile the few files that change and then relink.</p>

<p>我们的程序很小，只用了上面三行build脚本就搞定了。然而，随着项目的增长，这里会有更多的源代码文件和对象文件需要管理。在源码中任意一行代码的更改都需要重新编译所有的东西。它必须只去编译和链接那些更改的文件。</p>

<p>But how do we know what to recompile? Keeping track of that would be quite error prone if we tried to do that by hand. Here is where Rake become useful.</p>

<p>但是我们怎么指导哪些需要重新编译？ 如果我们尝试手动的去跟踪常常会遇到一些错误。这时候Rake就派上用场了。</p>

<p><strong>File Dependencies</strong></p>

<p>文件依赖</p>

<p>First, lets take a look at when files need to be recompiled. Consider the main.o. Obviously if the main.c file changes, then we need to rebuild main.o. But are the other files that can trigger a recompile of main.o?</p>

<p>首先，让我们看看哪些文件需要重新编译的。看一下 main.o，显然的，如果 main.c 文件更改了，那么我们需要重新build main.o。 但是其他的文件也会触发重新编译main.o？</p>

<p>Actually, yes. Looking at the source of main.c, we see that it includes the header file greet.h. That means any changes in greet.h could possibly effect the main.o file as well.</p>

<p>事实上是的。看main.c的源代码，我们看到它包含了一个头文件greet.h。那意味着greet.h的改变也会影响main.o。</p>

<p>We say that main.o has a dependency on the files main.c and greet.h. We can capture this dependency in Rake with the following line:</p>

<p>由此我们可以知道main.o依赖main.c和greet.h。使用Rake我们可以使用一行代码去处理这个依赖问题。</p>

<p><strong>Rakefile Fragment</strong></p>

<p>Rakefile 片段</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">file</span> <span class="s2">&quot;main.o&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.c&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.h&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The rake dependency declaration is just regular Ruby code. We take advantage of the fact that we can construct hash arguments on the fly, and that Ruby doesn’t require parenthesis around the method arguement to create a file task declaration that reads very naturally to the humans reading the rake file. But its still just Ruby code.</p>

<p>rake依赖定义是一个正常的Ruby代码。实际上我们利用hash的参数结构，Ruby不需要括号来包裹方法的参数，创建文件任务定义读起来是那么的自然，可度性很高。 但是它只是Ruby代码。</p>

<p>Likewise, we can declare the dependencies for creating the “greet.o” file as well.</p>

<p>同样的，我们定义一个创建“greet.o”的依赖关系。</p>

<p><strong>Rakefile Fragment</strong></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">file</span> <span class="s2">&quot;greet.o&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;greet.c&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>greet.c does include stdio.h, but since that is a system header file and not subject to change (often), we can leave itout of the dependency list.</p>

<p>greet.c包含stdio.h，但是系统头文件常常不会变动，我们可以不用再写它的依赖列表。</p>

<p>Finally we can declare the dependencies for the executable program hello. It just depends on the two object files.</p>

<p>最终，我们可以定义可执行文件hello的依赖关系。它只依赖两个对象文件。</p>

<p><strong>Rakefile Fragment</strong></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">file</span> <span class="s2">&quot;hello&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.o&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.o&quot;</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Notice that we only have to declare the direct dependencies of hello. Yes, hello depends on main.o which in turn depends on main.c. But the .c files are not directly used in building hello, so they can safely be omitted from the list.</p>

<p>提醒一下，我们只是定义了hello的直接依赖。hello依赖main.o它又依赖main.c。但是.c源码文件没有直接用来build hello，所以它可以安全的被忽略。</p>

<p><strong>Building the Files</strong></p>

<p>We have carefully specified how the files are related. Now we need to say what Rake would have to do to build the files when needed.</p>

<p>我们仔细的指定这些文件是如何关联的。现在我们需要说rake是怎么去build这些文件的。</p>

<p>This part is pretty simple. The three line build script that we started with contains all the commands needed to build the program. We just need to put those actions with the right set of dependencies. Use a Ruby do / end block to capture actions …</p>

<p>这部分相当的简单。这三行build脚本包含了build程序所有的命令。我们只要把它们放在正确的依赖关系上。使用Ruby的 do/end 块去包裹这些指令。</p>

<p>The result looks like this:</p>

<p>结果看上去如下</p>

<p><strong>Rakefile</strong></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt; file &#39;main.o&#39; =&gt; [&quot;main.c&quot;, &quot;greet.h&quot;] do&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">sh</span> <span class="s2">&quot;cc -c -o main.o main.c&quot;</span>
</span><span class='line'><span class="o">&lt;</span><span class="sr">/code&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span> <span class="k">end</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt; file &#39;greet.o&#39; =&gt; [&#39;greet.c&#39;] do</span>
</span><span class='line'><span class="sr">   sh &quot;cc -c -o greet.o greet.c&quot;</span>
</span><span class='line'><span class="sr"> end&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span><span class="n">file</span> <span class="s2">&quot;hello&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;main.o&quot;</span><span class="p">,</span> <span class="s2">&quot;greet.o&quot;</span><span class="o">]</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">sh</span> <span class="s2">&quot;cc -o hello main.o greet.o&quot;</span>
</span><span class='line'><span class="k">end</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p><strong>Trying it out</strong></p>

<p>So, let’s see if it works!</p>

<p>然我们看看它是怎么工作的吧。</p>

<p><strong>Output</strong></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rake hello
</span><span class='line'>  <span class="o">(</span>in /home/jim/pgm/rake/intro<span class="o">)</span>
</span><span class='line'>  cc -c -o main.o main.c
</span><span class='line'>  cc -c -o greet.o greet.c
</span><span class='line'>  cc -o hello main.o greet.o
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>The command line rake hello instructs rake to look through its list of tasks and find one called “hello”. It then checks hello’s dependencies and builds them if required. Finally, when everything is ready it builds hello by executing the C compiler command.</p>

<p>命令rake hello告诉rake去到任务列表中找到一个叫“hello”的任务。然后它检查build hello的依赖关系。最终，准备妥当后执行C编译命令。</p>

<p>Rake dutifully reports what it is doing as it goes along. We can see that each compiler invocation is done in the correct order, building the main program at the end. So, does the program work? Let’s find out.</p>

<p>Rake诚实的报告了它独自做了什么事情。我们看到build main程序从都到尾调用的顺序。</p>

<p><strong>Output</strong></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./hello
</span><span class='line'>Hello, World
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Success!</p>

<p>搞定</p>

<p>But what happens when we change a file. Lets change the greet function in greet.c to print “Hi” instead of hello.</p>

<p>但是我们更改了一个文件后会发生什么事情呢？ 我们来修改greet.c文件中的greet方法，用打印“Hi”去替换hello。</p>

<p><strong>Output</strong></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>emacs greet.c
</span><span class='line'><span class="nv">$ </span>rake hello
</span><span class='line'><span class="o">(</span>in /home/jim/pgm/rake/intro<span class="o">)</span>
</span><span class='line'>cc -c -o greet.o greet.c
</span><span class='line'>cc -o hello main.o greet.o
</span><span class='line'><span class="err">$</span>
</span><span class='line'><span class="nv">$ </span>./hello
</span><span class='line'>Hi, World
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Notice that it recompiles greet.c making a new greet.o. And then it needs to relink hello with the new greet.o. Then it is done. There is no need to recompile main.c since it never changed.</p>

<p>提示，它重新编译了greet.c去创建新的greet.o。之后，它需要用新的greet.o去重新link hello。这样就完成了。由于main.c没有任何的改变，在这里不需要重新编译。</p>

<p>What do you think will happend if we run Rake again?</p>

<p>你认为重新执行Rake会发生什么事情？</p>

<p><strong>Output</strong></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rake hello
</span><span class='line'><span class="o">(</span>in /home/jim/pgm/rake/intro<span class="o">)</span>
</span><span class='line'><span class="err">$</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>That’s right … nothing. Everything is up to date with its dependencies, so there is no work for Rake to do.</p>

<p>哈哈，什么也没发生。所有的都是最新的，所以Rake不需要做任何事情。</p>

<p>Ok, sure. Rake is a bit of overkill for only two source files and a header. But imagine a large project with hundreds of files and dependencies. All of a sudden, a tool like Rake becomes very attractive.</p>

<p>的确，Rake对只有两个源码和一个头文件的项目十分在行。但是，想象一个大项目，有上百个文件和依赖关系，像Rake这样的工具也会非常地受欢迎。</p>

<h4>Summary</h4>

<p>What have we learned? Building a Rakefile involves identifying dependencies and the actions required to create the target files. Then declaring the dependencies and actions are as simple as writing them down in standard Ruby code. Rake then handles the details of building</p>

<p>我们学到了什么？Building一个Rakefile，去识别创建目标文件的依赖关系和动作。然后用标准的Rbuy代码去定义和处理这些依赖和动作。Rake去处理building的细节。</p>

<h4>What’s Up Next</h4>

<p>接下来</p>

<p>We notice that even our small example has a bit of duplication in it. We have specify how to compile both C file separately, even though the only difference is the files that are used. The next installment will look at fixing that problem as well as introduce non-file based tasks, rules and file lists.</p>

<p>我们依然会用一个小的示例。我们会指定如何独立地编译C文件，即使是使用上的区别。下面问会解决一些文件无关的任务规则。</p>
]]></content>
  </entry>
  
</feed>
